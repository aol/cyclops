package cyclops.companion;

import java.util.concurrent.*;
import java.util.function.*;
import java.util.stream.Stream;

import com.oath.cyclops.hkt.Higher;

import com.oath.cyclops.types.traversable.IterableX;
import cyclops.control.Option;
import cyclops.typeclasses.*;
import cyclops.control.Either;
import com.oath.cyclops.hkt.DataWitness.future;
import cyclops.typeclasses.Active;
import cyclops.typeclasses.InstanceDefinitions;
import cyclops.control.Future;
import cyclops.control.Maybe;
import cyclops.function.Function3;
import cyclops.function.Function4;
import cyclops.function.Monoid;
import cyclops.function.Reducer;
import com.oath.cyclops.hkt.DataWitness.completableFuture;

import cyclops.typeclasses.comonad.Comonad;
import cyclops.typeclasses.foldable.Foldable;
import cyclops.typeclasses.foldable.Unfoldable;
import cyclops.typeclasses.functions.MonoidK;
import cyclops.typeclasses.functions.MonoidKs;
import cyclops.typeclasses.functor.Functor;
import cyclops.typeclasses.instances.General;
import cyclops.typeclasses.monad.*;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import org.reactivestreams.Publisher;

import cyclops.reactive.ReactiveSeq;

import lombok.experimental.UtilityClass;

/**
 * Utilty methods for working with JDK CompletableFutures
 *
 * @author johnmcclean
 *
 */
@UtilityClass
public class CompletableFutures {

    public static <T> CompletableFuture<T> error(Throwable t){
        CompletableFuture<T> cf = new CompletableFuture<>();
        cf.completeExceptionally(t);
        return cf;
    }
    public static  <T,R> CompletableFuture<R> tailRec(T initial, Function<? super T, ? extends CompletableFuture<? extends Either<T, R>>> fn){
        Higher<future, R> x = Future.Instances.monadRec().tailRec(initial, fn.andThen(Future::of));
        return Future.narrowK(x).getFuture();
    }

    public static  <T> Kleisli<completableFuture,CompletableFuture<T>,T> kindKleisli(){
        return Kleisli.of(CompletableFutures.Instances.monad(), CompletableFutures::widen);
    }
    public static <T> Higher<completableFuture, T> widen(CompletableFuture<T> narrow) {
        return CompletableFutures.CompletableFutureKind.widen(narrow);
    }
    public static  <T> Cokleisli<completableFuture,T,CompletableFuture<T>> kindCokleisli(){
        return Cokleisli.of(CompletableFutures.CompletableFutureKind::narrowK);
    }
    public static <T> CompletableFuture<T> ofResult(T value){
        CompletableFuture<T> result = new CompletableFuture<T>();
        result.complete(value);
        return result;
    }
    public static <W1,T> Nested<completableFuture,W1,T> nested(CompletableFuture<Higher<W1,T>> nested, InstanceDefinitions<W1> def2){
        return Nested.of(CompletableFutureKind.widen(nested), Instances.definitions(),def2);
    }
    public <W1,T> Product<completableFuture,W1,T> product(CompletableFuture<T> f,Active<W1,T> active){
        return Product.of(allTypeclasses(f),active);
    }

    public static <W1,T> Coproduct<W1,completableFuture,T> coproduct(CompletableFuture<T> f,InstanceDefinitions<W1> def2){
        return Coproduct.right(CompletableFutureKind.widen(f),def2,Instances.definitions());
    }
    public static <T> Active<completableFuture,T> allTypeclasses(CompletableFuture<T> f){
        return Active.of(CompletableFutureKind.widen(f), Instances.definitions());
    }
    public <W2,T,R> Nested<completableFuture,W2,R> mapM(CompletableFuture<T> f,Function<? super T,? extends Higher<W2,R>> fn, InstanceDefinitions<W2> defs){
        CompletableFuture<Higher<W2, R>> x = f.thenApply(fn);
        return nested(x,defs);

    }




    /**
     * Perform a For Comprehension over a CompletableFuture, accepting 3 generating function.
     * This results in a four level nested internal iteration over the provided CompletableFutures.
     *
     *  <pre>
     * {@code
     *
     *   import static com.oath.cyclops.reactor.CompletableFutures.forEach4;
     *
    forEach4(CompletableFuture.just(1),
    a-> CompletableFuture.just(a+1),
    (a,b) -> CompletableFuture.<Integer>just(a+b),
    a                  (a,b,c) -> CompletableFuture.<Integer>just(a+b+c),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level CompletableFuture
     * @param value2 Nested CompletableFuture
     * @param value3 Nested CompletableFuture
     * @param value4 Nested CompletableFuture
     * @param yieldingFunction Generates a result per combination
     * @return CompletableFuture with a combined value generated by the yielding function
     */
    public static <T1, T2, T3, R1, R2, R3, R> CompletableFuture<R> forEach4(CompletableFuture<? extends T1> value1,
                                                                            Function<? super T1, ? extends CompletableFuture<R1>> value2,
                                                                            BiFunction<? super T1, ? super R1, ? extends CompletableFuture<R2>> value3,
                                                                            Function3<? super T1, ? super R1, ? super R2, ? extends CompletableFuture<R3>> value4,
                                                                            Function4<? super T1, ? super R1, ? super R2, ? super R3, ? extends R> yieldingFunction) {

        return value1.thenCompose(in -> {

            CompletableFuture<R1> a = value2.apply(in);
            return a.thenCompose(ina -> {
                CompletableFuture<R2> b = value3.apply(in,ina);
                return b.thenCompose(inb -> {
                    CompletableFuture<R3> c = value4.apply(in,ina,inb);
                    return c.thenApply(in2 -> yieldingFunction.apply(in, ina, inb, in2));
                });

            });

        });

    }



    /**
     * Perform a For Comprehension over a CompletableFuture, accepting 2 generating function.
     * This results in a three level nested internal iteration over the provided CompletableFutures.
     *
     *  <pre>
     * {@code
     *
     *   import static com.oath.cyclops.reactor.CompletableFutures.forEach3;
     *
    forEach3(CompletableFuture.just(1),
    a-> CompletableFuture.just(a+1),
    (a,b) -> CompletableFuture.<Integer>just(a+b),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level CompletableFuture
     * @param value2 Nested CompletableFuture
     * @param value3 Nested CompletableFuture
     * @param yieldingFunction Generates a result per combination
     * @return CompletableFuture with a combined value generated by the yielding function
     */
    public static <T1, T2, R1, R2, R> CompletableFuture<R> forEach3(CompletableFuture<? extends T1> value1,
                                                                    Function<? super T1, ? extends CompletableFuture<R1>> value2,
                                                                    BiFunction<? super T1, ? super R1, ? extends CompletableFuture<R2>> value3,
                                                                    Function3<? super T1, ? super R1, ? super R2, ? extends R> yieldingFunction) {

        return value1.thenCompose(in -> {

            CompletableFuture<R1> a = value2.apply(in);
            return a.thenCompose(ina -> {
                CompletableFuture<R2> b = value3.apply(in,ina);


                    return b.thenApply(in2 -> yieldingFunction.apply(in, ina, in2));


            });

        });

    }


    /**
     * Perform a For Comprehension over a CompletableFuture, accepting a generating function.
     * This results in a two level nested internal iteration over the provided CompletableFutures.
     *
     *  <pre>
     * {@code
     *
     *   import static com.oath.cyclops.reactor.CompletableFutures.forEach;
     *
    forEach(CompletableFuture.just(1),
    a-> CompletableFuture.just(a+1),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level CompletableFuture
     * @param value2 Nested CompletableFuture
     * @param yieldingFunction Generates a result per combination
     * @return CompletableFuture with a combined value generated by the yielding function
     */
    public static <T, R1, R> CompletableFuture<R> forEach2(CompletableFuture<? extends T> value1, Function<? super T, CompletableFuture<R1>> value2,
                                                          BiFunction<? super T, ? super R1, ? extends R> yieldingFunction) {

        return value1.thenCompose(in -> {

            CompletableFuture<R1> a = value2.apply(in);
            return a.thenApply(ina -> yieldingFunction.apply(in, ina));


            });


    }


    /**
     * Asynchronous sequence operation that convert a Collection of Futures to a Future with a List
     *
     * <pre>
     * {@code
     *   CompletableFuture<ListX<Integer>> futures =CompletableFuture.sequence(ListX.of(
     *                                                          CompletableFuture.completedFuture(10),
     *                                                          CompletableFuture.completedFuture(1)));
         //ListX.of(10,1)
     *
     * }
     * </pre>
     *
     *
     * @param fts Collection of Futures to Sequence into a Future with a List
     * @return Future with a List
     */
    public static <T> CompletableFuture<ReactiveSeq<T>> sequence(final IterableX<? extends CompletableFuture<T>> fts) {
        return sequence(fts.stream());
    }
    /**
     * Asynchronous sequence operation that convert a Stream of Futures to a Future with a Stream
     *
     * <pre>
     * {@code
     *   CompletableFuture<ListX<Integer>> futures =CompletableFuture.sequence(ListX.of(
     *                                                          CompletableFuture.completedFuture(10),
     *                                                          CompletableFuture.completedFuture(1)));
         //ListX.of(10,1)
     *
     * }
     * </pre>
     *
     *
     * @param fts Stream of Futures to Sequence into a Future with a Stream
     * @return Future with a Stream
     */
    public static <T> CompletableFuture<ReactiveSeq<T>> sequence(final Stream<? extends CompletableFuture<T>> fts) {
        return sequence(ReactiveSeq.fromStream((fts)));

    }
  public static  <T> CompletableFuture<ReactiveSeq<T>> sequence(ReactiveSeq<? extends CompletableFuture<T>> stream) {

    CompletableFuture<ReactiveSeq<T>> identity = CompletableFuture.completedFuture(ReactiveSeq.empty());

    BiFunction<CompletableFuture<ReactiveSeq<T>>,CompletableFuture<T>,CompletableFuture<ReactiveSeq<T>>> combineToStream = (acc,next) ->acc.thenCombine(next,(a,b)->a.appendAll(b));

    BinaryOperator<CompletableFuture<ReactiveSeq<T>>> combineStreams = (a,b)-> a.thenCombine(b,(z1,z2)->z1.appendS(z2));

    return stream.reduce(identity,combineToStream,combineStreams);
  }
  public static <T,R> CompletableFuture<ReactiveSeq<R>> traverse(Function<? super T,? extends R> fn,ReactiveSeq<CompletableFuture<T>> stream) {
    ReactiveSeq<CompletableFuture<R>> s = stream.map(h -> h.thenApply(fn));
    return sequence(s);
  }
    /**
     *
     * Asynchronously accumulate the results only from those Futures which have completed successfully.
     * Also @see {@link CompletableFutures#accumulate(IterableX, Reducer)} if you would like a failure to result in a CompletableFuture
     * with an error
     * <pre>
     * {@code
     *
     * CompletableFuture<Integer> just = CompletableFuture.completedFuture(10);
      CompletableFuture<Integer> none = Future.ofError(new NoSuchElementException())
                                               .getFuture();

     * CompletableFuture<PersistentSetX<Integer>> futures = CompletableFutures.accumulateSuccess(ListX.of(just,none,CompletableFuture.completedFuture(1)),Reducers.toPersistentSetX());

       //CompletableFuture[PersistentSetX[10,1]]
     *  }
     *  </pre>
     *
     * @param fts Collection of Futures to accumulate successes
     * @param reducer Reducer to accumulate results
     * @return CompletableFuture asynchronously populated with the accumulate success operation
     */
    public static <T, R> CompletableFuture<R> accumulateSuccess(final IterableX<CompletableFuture<T>> fts, final Reducer<R,T> reducer) {
        CompletableFuture<R> result = new CompletableFuture<>();
        Stream<T> successes = fts.stream()
                                                    .filter(ft->!ft.isCompletedExceptionally())
                                                    .map(CompletableFuture::join);
        CompletableFuture.allOf(fts.toArray(i->new CompletableFuture[i]))
                        .thenRun(()-> result.complete(reducer.mapReduce(successes)))
                        .exceptionally(e->{ result.complete(reducer.mapReduce(successes)); return null;});

        return result;
    }
    /**
     * Asynchronously accumulate the results only from those Futures which have completed successfully, using the supplied mapping function to
     * convert the data from each Future before reducing them using the supplied Monoid (a combining BiFunction/BinaryOperator and identity element that takes two
     * input values of the same type and returns the combined result) {@see cyclops2.Monoids }.
     *
     * <pre>
     * {@code
     * CompletableFuture<String> future = CompletableFutures.accumulate(ListX.of(CompletableFuture.completedFuture(10),CompletableFuture.completedFuture(1)),i->""+i,Monoids.stringConcat);
        //CompletableFuture["101"]
     * }
     * </pre>
     *
     * @param fts Collection of Futures to accumulate successes
     * @param mapper Mapping function to be applied to the result of each Future
     * @param reducer Monoid to combine values from each Future
     * @return CompletableFuture asynchronously populated with the accumulate operation
     */
    public static <T, R> CompletableFuture<R> accumulateSuccess(final IterableX<CompletableFuture<T>> fts,final Function<? super T, R> mapper,final Monoid<R> reducer) {
        CompletableFuture<R> result = new CompletableFuture<>();
        ReactiveSeq<R> successes = fts.stream()
                                      .filter(ft->!ft.isCompletedExceptionally())
                                      .map(CompletableFuture::join)
                                      .map(mapper);
        CompletableFuture.allOf(fts.toArray(i->new CompletableFuture[i]))
                        .thenRun(()-> result.complete(successes.reduce(reducer)))
                        .exceptionally(e->{ result.complete(successes.reduce(reducer)); return null;});

        return result;
    }
    /**
     * Asynchronously accumulate the results only from those Futures which have completed successfully,
     *  reducing them using the supplied Monoid (a combining BiFunction/BinaryOperator and identity element that takes two
     * input values of the same type and returns the combined result) {@see cyclops2.Monoids }
     *
     * <pre>
     * {@code
     * CompletableFuture<Integer> just =CompletableFuture.completedFuture(10);
     * CompletableFuture<Integer> future =CompletableFutures.accumulate(Monoids.intSum, ListX.of(just,CompletableFuture.completedFuture(1)));
       //CompletableFuture[11]
     * }
     * </pre>
     *
     *
     * @param fts Collection of Futures to accumulate successes
     * @param reducer Monoid to combine values from each Future
     * @return CompletableFuture asynchronously populated with the accumulate operation
     */
    public static <T, R> CompletableFuture<T> accumulateSuccess(final Monoid<T> reducer,final IterableX<CompletableFuture<T>> fts) {
        CompletableFuture<T> result = new CompletableFuture<>();
        ReactiveSeq<T> successes = fts.stream()
                                      .filter(ft->!ft.isCompletedExceptionally())
                                      .map(CompletableFuture::join);
        CompletableFuture.allOf(fts.toArray(i->new CompletableFuture[i]))
                        .thenRun(()-> result.complete(successes.reduce(reducer)))
                        .exceptionally(e->{ result.complete(successes.reduce(reducer)); return null;});

        return result;
    }
    /**
     * Asynchronously accumulate the results of Futures, a single failure will cause a failed result, using the supplied Reducer {@see cyclops2.Reducers}
     * <pre>
     * {@code
     *
     * CompletableFuture<Integer> just =CompletableFuture.completedFuture(10);
       CompletableFuture<Integer> none = Future.ofError(new NoSuchElementException()).getFuture();

     * CompletableFuture<PersistentSetX<Integer>> futures = CompletableFutures.accumulateSuccess(ListX.of(just,none,CompletableFuture.completedFuture(1)),Reducers.toPersistentSetX());

       //CompletableFuture[PersistentSetX[10,1]]
     *  }
     *  </pre>
     *
     * @param fts Collection of Futures to accumulate successes
     * @param reducer Reducer to accumulate results
     * @return Future asynchronously populated with the accumulate success operation
     */
    public static <T, R> CompletableFuture<R> accumulate(final IterableX<CompletableFuture<T>> fts, final Reducer<R,T> reducer) {
        return sequence(fts).thenApply(s -> s.mapReduce(reducer));
    }
    /**
     * Asynchronously accumulate the results of a batch of Futures which using the supplied mapping function to
     * convert the data from each Future before reducing them using the supplied supplied Monoid (a combining BiFunction/BinaryOperator and identity element that takes two
     * input values of the same type and returns the combined result) {@see cyclops2.Monoids }.
     * A single Failure results in a Failed  Future.
     *
     * <pre>
     * {@code
     * CompletableFuture<String> future = Future.accumulate(ListX.of(CompletableFuture.completedFuture(10),CompletableFuture.completedFuture(1)),i->""+i,Monoids.stringConcat);
        //CompletableFuture["101"]
     * }
     * </pre>
     *
     * @param fts Collection of Futures to accumulate successes
     * @param mapper Mapping function to be applied to the result of each Future
     * @param reducer Monoid to combine values from each Future
     * @return CompletableFuture asynchronously populated with the accumulate operation
     */
    public static <T, R> CompletableFuture<R> accumulate(final IterableX<CompletableFuture<T>> fts, final Function<? super T, R> mapper,
            final Monoid<R> reducer) {
        return sequence(fts).thenApply(s -> s.map(mapper)
                                             .reduce(reducer));
    }
    /**
     * Asynchronously accumulate the results only from the provided Futures,
     *  reducing them using the supplied Monoid (a combining BiFunction/BinaryOperator and identity element that takes two
     * input values of the same type and returns the combined result) {@see cyclops2.Monoids }.
     *
     * A single Failure results in a Failed  Future.
     *
     * <pre>
     * {@code
     * CompletableFuture<Integer> just =CompletableFuture.completedFuture(10);
     *
     * CompletableFuture<Integer> future =CompletableFutures.accumulate(Monoids.intSum,ListX.of(just,CompletableFuture.completableFuture(1)));
       //CompletableFuture[11]
     * }
     * </pre>
     *
     *
     * @param fts Collection of Futures to accumulate successes
     * @param reducer Monoid to combine values from each Future
     * @return CompletableFuture asynchronously populated with the accumulate operation
     */
    public static <T> CompletableFuture<T> accumulate(final Monoid<T> reducer, final IterableX<CompletableFuture<T>> fts
           ) {
        return sequence(fts).thenApply(s -> s
                                             .reduce(reducer));
    }
    /**
     * Schedule the population of a CompletableFuture from the provided Supplier, the provided Cron (Quartz format) expression will be used to
     * trigger the population of the CompletableFuture. The provided ScheduledExecutorService provided the thread on which the
     * Supplier will be executed.
     *
     * <pre>
     * {@code
     *
     *    CompletableFuture<String> future = CompletableFutures.schedule("* * * * * ?", Executors.newScheduledThreadPool(1), ()->"hello");
     *
     *    //CompletableFuture["hello"]
     *
     * }</pre>
     *
     *
     * @param cron Cron expression in Quartz format
     * @param ex ScheduledExecutorService used to execute the provided Supplier
     * @param t The Supplier to execute to populate the CompletableFuture
     * @return CompletableFuture populated on a Cron based Schedule
     */
    public static <T> CompletableFuture<T> schedule(final String cron, final ScheduledExecutorService ex, final Supplier<T> t) {
        return Future.schedule(cron, ex, t)
                      .getFuture();
    }
    /**
     * Schedule the population of a CompletableFuture from the provided Supplier after the specified delay. The provided ScheduledExecutorService provided the thread on which the
     * Supplier will be executed.
     * <pre>
     * {@code
     *
     *    CompletableFuture<String> future = CompletableFutures.schedule(10l, Executors.newScheduledThreadPool(1), ()->"hello");
     *
     *    //CompletableFuture["hello"]
     *
     * }</pre>
     *
     * @param delay Delay after which the CompletableFuture should be populated
     * @param ex ScheduledExecutorService used to execute the provided Supplier
     * @param t he Supplier to execute to populate the CompletableFuture
     * @return CompletableFuture populated after the specified delay
     */
    public static <T> CompletableFuture<T> schedule(final long delay, final ScheduledExecutorService ex, final Supplier<T> t) {
        return Future.schedule(delay, ex, t)
                      .getFuture();
    }

  /**
     * Combine an CompletableFuture with the provided Iterable (selecting one element if present) using the supplied BiFunction
     * <pre>
     * {@code
     *  CompletableFutures.zip(CompletableFuture.completedFuture(10),Arrays.asList(20), this::add)
     *  //CompletableFuture[30]
     *
     *  private int add(int a, int b) {
            return a + b;
        }
     *
     * }
     * </pre>
     * @param f CompletableFuture to combine with first element in Iterable (if present)
     * @param v Iterable to combine
     * @param fn Combining function
     * @return CompletableFuture combined with supplied Iterable
     */
    public static <T1, T2, R> CompletableFuture<R> zip(final CompletableFuture<? extends T1> f, final Iterable<? extends T2> v,
            final BiFunction<? super T1, ? super T2, ? extends R> fn) {
        return narrow(Future.of(f)
                             .zip(v, fn)
                             .getFuture());
    }
  public static <T1, T2, R> CompletableFuture<R> zip(final CompletableFuture<? extends T1> f, final CompletableFuture<? extends T2> v,
                                                     final BiFunction<? super T1, ? super T2, ? extends R> fn) {
    return zip(f,Future.of(v),fn);
  }
    /**
     * Combine an CompletableFuture with the provided Publisher (selecting one element if present) using the supplied BiFunction
     * <pre>
     * {@code
     *  CompletableFutures.zip(Flux.just(10),CompletableFuture.completedResult(10), this::add)
     *  //CompletableFuture[30]
     *
     *  private int add(int a, int b) {
            return a + b;
        }
     *
     * }
     * </pre>
     *
     * @param p Publisher to combine
     * @param f  CompletableFuture to combine with
     * @param fn Combining function
     * @return CompletableFuture combined with supplied Publisher
     */
    public static <T1, T2, R> CompletableFuture<R> zip(final Publisher<? extends T2> p, final CompletableFuture<? extends T1> f,
            final BiFunction<? super T1, ? super T2, ? extends R> fn) {
        return narrow(Future.of(f)
                             .zip(fn, p)
                             .getFuture());
    }
    /**
     * Narrow covariant type parameter
     *
     * @param f CompletableFuture with covariant type parameter
     * @return Narrowed Future
     */
    public static <T> CompletableFuture<T> narrow(final CompletableFuture<? extends T> f) {
        return (CompletableFuture<T>) f;
    }
    /**
     * Companion class for creating Type Class instances for working with CompletableFutures
     * @author johnmcclean
     *
     */
    @UtilityClass
    public static class Instances {
        public static InstanceDefinitions<completableFuture> definitions(){
            return new InstanceDefinitions<completableFuture>() {
                @Override
                public <T, R> Functor<completableFuture> functor() {
                    return Instances.functor();
                }

                @Override
                public <T> Pure<completableFuture> unit() {
                    return Instances.unit();
                }

                @Override
                public <T, R> Applicative<completableFuture> applicative() {
                    return Instances.applicative();
                }

                @Override
                public <T, R> Monad<completableFuture> monad() {
                    return Instances.monad();
                }

                @Override
                public <T, R> Option<MonadZero<completableFuture>> monadZero() {
                    return Option.some(Instances.monadZero());
                }

                @Override
                public <T> Option<MonadPlus<completableFuture>> monadPlus() {
                    return Option.some(Instances.monadPlus());
                }

                @Override
                public <T> MonadRec<completableFuture> monadRec() {
                    return Instances.monadRec();
                }

                @Override
                public <T> Option<MonadPlus<completableFuture>> monadPlus(MonoidK<completableFuture> m) {
                    return Option.some(Instances.monadPlus(m));
                }

                @Override
                public <C2, T> Traverse<completableFuture> traverse() {
                    return Instances.traverse();
                }

                @Override
                public <T> Foldable<completableFuture> foldable() {
                    return Instances.foldable();
                }

                @Override
                public <T> Option<Comonad<completableFuture>> comonad() {
                    return Maybe.just(Instances.comonad());
                }

                @Override
                public <T> Option<Unfoldable<completableFuture>> unfoldable() {
                    return Maybe.nothing();
                }
            };
        }

        /**
         *
         * Transform a future, mulitplying every element by 2
         *
         * <pre>
         * {@code
         *  CompletableFutureKind<Integer> future = CompletableFutures.functor().map(i->i*2, CompletableFutureKind.widen(CompletableFuture.completedFuture(1,2,3));
         *
         *  //[2,4,6]
         *
         *
         * }
         * </pre>
         *
         * An example fluent api working with CompletableFutures
         * <pre>
         * {@code
         *   CompletableFutureKind<Integer> future = CompletableFutures.unit()
        .unit("hello")
        .applyHKT(h->CompletableFutures.functor().map((String v) ->v.length(), h))
        .convert(CompletableFutureKind::narrowK3);
         *
         * }
         * </pre>
         *
         *
         * @return A functor for CompletableFutures
         */
        public static <T,R>Functor<completableFuture> functor(){
            BiFunction<CompletableFutureKind<T>,Function<? super T, ? extends R>,CompletableFutureKind<R>> map = Instances::map;
            return General.functor(map);
        }
        /**
         * <pre>
         * {@code
         * CompletableFutureKind<String> future = CompletableFutures.unit()
        .unit("hello")
        .convert(CompletableFutureKind::narrowK3);

        //CompletableFuture.completedFuture("hello"))
         *
         * }
         * </pre>
         *
         *
         * @return A factory for CompletableFutures
         */
        public static <T> Pure<completableFuture> unit(){
            return General.<completableFuture,T>unit(Instances::of);
        }
        /**
         *
         * <pre>
         * {@code
         * import static com.aol.cyclops.hkt.jdk.CompletableFutureKind.widen;
         * import static com.aol.cyclops.util.function.Lambda.l1;
         *
        CompletableFutures.applicative()
        .ap(widen(asCompletableFuture(l1(this::multiplyByTwo))),widen(asCompletableFuture(3)));
         *
         * //[6]
         * }
         * </pre>
         *
         *
         * Example fluent API
         * <pre>
         * {@code
         * CompletableFutureKind<Function<Integer,Integer>> futureFn =CompletableFutures.unit()
         *                                                  .unit(Lambda.l1((Integer i) ->i*2))
         *                                                  .convert(CompletableFutureKind::narrowK3);

        CompletableFutureKind<Integer> future = CompletableFutures.unit()
        .unit("hello")
        .applyHKT(h->CompletableFutures.functor().map((String v) ->v.length(), h))
        .applyHKT(h->CompletableFutures.applicative().ap(futureFn, h))
        .convert(CompletableFutureKind::narrowK3);

        //CompletableFuture.completedFuture("hello".length()*2))
         *
         * }
         * </pre>
         *
         *
         * @return A zipper for CompletableFutures
         */
        public static <T,R> Applicative<completableFuture> applicative(){
            BiFunction<CompletableFutureKind< Function<T, R>>,CompletableFutureKind<T>,CompletableFutureKind<R>> ap = Instances::ap;
            return General.applicative(functor(), unit(), ap);
        }
        /**
         *
         * <pre>
         * {@code
         * import static com.aol.cyclops.hkt.jdk.CompletableFutureKind.widen;
         * CompletableFutureKind<Integer> future  = CompletableFutures.monad()
        .flatMap(i->widen(CompletableFutureX.range(0,i)), widen(CompletableFuture.completedFuture(3)))
        .convert(CompletableFutureKind::narrowK3);
         * }
         * </pre>
         *
         * Example fluent API
         * <pre>
         * {@code
         *    CompletableFutureKind<Integer> future = CompletableFutures.unit()
        .unit("hello")
        .applyHKT(h->CompletableFutures.monad().flatMap((String v) ->CompletableFutures.unit().unit(v.length()), h))
        .convert(CompletableFutureKind::narrowK3);

        //CompletableFuture.completedFuture("hello".length())
         *
         * }
         * </pre>
         *
         * @return Type class with monad functions for CompletableFutures
         */
        public static <T,R> Monad<completableFuture> monad(){

            BiFunction<Higher<completableFuture,T>,Function<? super T, ? extends Higher<completableFuture,R>>,Higher<completableFuture,R>> flatMap = Instances::flatMap;
            return General.monad(applicative(), flatMap);
        }
        /**
         *
         * <pre>
         * {@code
         *  CompletableFutureKind<String> future = CompletableFutures.unit()
        .unit("hello")
        .applyHKT(h->CompletableFutures.monadZero().filter((String t)->t.startsWith("he"), h))
        .convert(CompletableFutureKind::narrowK3);

        //CompletableFuture.completedFuture("hello"));
         *
         * }
         * </pre>
         *
         *
         * @return A filterable monad (with default value)
         */
        public static <T,R> MonadZero<completableFuture> monadZero(){

            return General.monadZero(monad(), CompletableFutureKind.widen(new CompletableFuture<T>()));
        }

        public static <T> MonadPlus<completableFuture> monadPlus(){

            return General.monadPlus(monadZero(), MonoidKs.firstCompleteCompletableFuture());
        }

        public static  <T> MonadPlus<completableFuture> monadPlus(MonoidK<completableFuture> m){

            return General.monadPlus(monadZero(),m);
        }

        /**
         * @return Type class for traversables with traverse / sequence operations
         */
        public static <C2,T> Traverse<completableFuture> traverse(){

            return General.traverseByTraverse(applicative(), Instances::traverseA);
        }

        /**
         *
         * <pre>
         * {@code
         * int sum  = CompletableFutures.foldable()
        .foldLeft(0, (a,b)->a+b, CompletableFutureKind.widen(CompletableFuture.completedFuture(3)));

        //3
         *
         * }
         * </pre>
         *
         *
         * @return Type class for folding / reduction operations
         */
        public static <T,R> Foldable<completableFuture> foldable(){
            BiFunction<Monoid<T>,Higher<completableFuture,T>,T> foldRightFn =  (m, l)-> m.apply(m.zero(), CompletableFutureKind.narrowK(l).join());
            BiFunction<Monoid<T>,Higher<completableFuture,T>,T> foldLeftFn = (m, l)->  m.apply(m.zero(), CompletableFutureKind.narrowK(l).join());
            Function3<Monoid<R>, Function<T, R>, Higher<completableFuture, T>, R> foldMapFn = (m, f, l)-> Future.of(CompletableFutureKind.narrowK(l).thenApply(f)).fold(m);
            return General.foldable(foldRightFn, foldLeftFn,foldMapFn);
        }
        public static <T> Comonad<completableFuture> comonad(){
            Function<? super Higher<completableFuture, T>, ? extends T> extractFn = maybe -> maybe.convert(CompletableFutureKind::narrowK).join();
            return General.comonad(functor(), unit(), extractFn);
        }

        private <T> CompletableFutureKind<T> of(T value){
            return CompletableFutureKind.widen(CompletableFuture.completedFuture(value));
        }
        private static <T,R> CompletableFutureKind<R> ap(CompletableFutureKind<Function< T, R>> lt, CompletableFutureKind<T> future){
            return CompletableFutureKind.widen(lt.thenCombine(future, (a, b)->a.apply(b)));

        }
        private static <T,R> Higher<completableFuture,R> flatMap(Higher<completableFuture,T> lt, Function<? super T, ? extends  Higher<completableFuture,R>> fn){
            return CompletableFutureKind.widen(CompletableFutureKind.narrow(lt).thenCompose(fn.andThen(CompletableFutureKind::narrowK)));
        }
        private static <T,R> CompletableFutureKind<R> map(CompletableFutureKind<T> lt, Function<? super T, ? extends R> fn){
            return CompletableFutureKind.widen(lt.thenApply(fn));
        }


        private static <C2,T,R> Higher<C2, Higher<completableFuture, R>> traverseA(Applicative<C2> applicative, Function<? super T, ? extends Higher<C2, R>> fn,
                                                                                         Higher<completableFuture, T> ds){
            CompletableFuture<T> future = CompletableFutureKind.narrowK(ds);
            return applicative.map(CompletableFutureKind::completedFuture, fn.apply(future.join()));
        }
        public static <T,R> MonadRec<completableFuture> monadRec(){

            return new  MonadRec<completableFuture>(){

                @Override
                public <T, R> Higher<completableFuture, R> tailRec(T initial, Function<? super T, ? extends Higher<completableFuture, ? extends Either<T, R>>> fn) {
                    Higher<future, R> x = Future.Instances.monadRec().tailRec(initial, fn.andThen(CompletableFutureKind::narrowK).andThen(Future::of));
                    return CompletableFutureKind.narrowFuture(x);
                }
            };
        }

    }
    /**
     * Simulates Higher Kinded Types for CompletableFuture's
     *
     * CompletableFutureKind is a CompletableFuture and a Higher Kinded Type (Witness.completableFuture,T)
     *
     * @author johnmcclean
     *
     * @param <T> Data type stored within the CompletableFuture
     */

    public static interface CompletableFutureKind<T> extends Higher<completableFuture, T>, CompletionStage<T> {



        /**
         * Construct a HKT encoded completed CompletableFuture
         *
         * @param value To encode inside a HKT encoded CompletableFuture
         * @return Completed HKT encoded CompletableFuture
         */
        public static <T> CompletableFutureKind<T> completedFuture(T value){
            return widen(CompletableFuture.completedFuture(value));
        }



        public static <U> CompletableFutureKind<U> supplyAsync(Supplier<U> supplier) {
            return widen(CompletableFuture.supplyAsync(supplier));
        }


        public static <U> CompletableFutureKind<U> supplyAsync(Supplier<U> supplier,
                                                           Executor executor) {
            return widen(CompletableFuture.supplyAsync(supplier,executor));
        }


        public static CompletableFutureKind<Void> runAsync(Runnable runnable) {
            return widen(CompletableFuture.runAsync(runnable));
        }


        public static CompletableFutureKind<Void> runAsync(Runnable runnable,
                                                       Executor executor) {
            return widen(CompletableFuture.runAsync(runnable,executor));
        }

        /**
         * Convert a CompletableFuture to a simulated HigherKindedType that captures CompletableFuture nature
         * and CompletableFuture element data type separately. Recover via @see CompletableFutureKind#narrow
         *
         * If the supplied CompletableFuture implements CompletableFutureKind it is returned already, otherwise it
         * is wrapped into a CompletableFuture implementation that does implement CompletableFutureKind
         *
         * @param completableFuture CompletableFuture to widen to a CompletableFutureKind
         * @return CompletableFutureKind encoding HKT info about CompletableFutures
         */
        public static <T> CompletableFutureKind<T> widen(final CompletionStage<T> completableFuture) {
            if (completableFuture instanceof CompletableFutureKind)
                return (CompletableFutureKind<T>) completableFuture;
            return new Box<>(
                    completableFuture);
        }
        public static <T> CompletableFutureKind<T> fromFuture(final Future<T> completableFuture) {
           return widen(completableFuture.toCompletableFuture());
        }
        public static <T> CompletableFutureKind<T> narrowFuture(final Higher<future, T> future) {
            return fromFuture(Future.narrowK(future));
        }
        /**
         * Convert the raw Higher Kinded Type for CompletableFutureKind types into the CompletableFutureKind type definition class
         *
         * @param future HKT encoded list into a CompletableFutureKind
         * @return CompletableFutureKind
         */
        public static <T> CompletableFutureKind<T> narrow(final Higher<completableFuture, T> future) {
            return (CompletableFutureKind<T>)future;
        }

        /**
         * Convert the HigherKindedType definition for a CompletableFuture into
         *
         * @param completableFuture Type Constructor to convert back into narrowed type
         * @return CompletableFuture from Higher Kinded Type
         */
        public static <T> CompletableFuture<T> narrowK(final Higher<completableFuture, T> completableFuture) {
            if (completableFuture instanceof CompletionStage) {
                final CompletionStage<T> ft = (CompletionStage<T>) completableFuture;
                return CompletableFuture.completedFuture(1)
                        .thenCompose(f -> ft);
            }
            // this code should be unreachable due to HKT type checker
            final Box<T> type = (Box<T>) completableFuture;
            final CompletionStage<T> stage = type.narrow();
            return CompletableFuture.completedFuture(1)
                    .thenCompose(f -> stage);

        }

        @AllArgsConstructor(access = AccessLevel.PRIVATE)
        static final class Box<T> implements CompletableFutureKind<T> {

            private final CompletionStage<T> boxed;

            /**
             * @return wrapped CompletableFuture
             */
            public CompletionStage<T> narrow() {
                return boxed;
            }

            public Active<completableFuture,T> allTypeclasses(){
                return Active.of(this, Instances.definitions());
            }
            public <W2,R> Nested<completableFuture,W2,R> mapM(Function<? super T,? extends Higher<W2,R>> fn, InstanceDefinitions<W2> defs){
                return Nested.of(thenApply(fn),Instances.definitions(), defs);
            }
            @Override
            public <U> CompletableFutureKind<U> thenApply(final Function<? super T, ? extends U> fn) {
                return widen(boxed.thenApply(fn));
            }

            @Override
            public <U> CompletableFutureKind<U> thenApplyAsync(final Function<? super T, ? extends U> fn) {
                return widen(boxed.thenApplyAsync(fn));
            }

            @Override
            public <U> CompletableFutureKind<U> thenApplyAsync(final Function<? super T, ? extends U> fn,
                                                         final Executor executor) {
                return widen(boxed.thenApplyAsync(fn, executor));
            }

            @Override
            public CompletableFutureKind<Void> thenAccept(final Consumer<? super T> action) {
                return widen(boxed.thenAccept(action));
            }

            @Override
            public CompletableFutureKind<Void> thenAcceptAsync(final Consumer<? super T> action) {
                return widen(boxed.thenAcceptAsync(action));
            }

            @Override
            public CompletableFutureKind<Void> thenAcceptAsync(final Consumer<? super T> action, final Executor executor) {
                return widen(boxed.thenAcceptAsync(action, executor));
            }

            @Override
            public CompletableFutureKind<Void> thenRun(final Runnable action) {
                return widen(boxed.thenRun(action));
            }

            @Override
            public CompletableFutureKind<Void> thenRunAsync(final Runnable action) {
                return widen(boxed.thenRunAsync(action));
            }

            @Override
            public CompletableFutureKind<Void> thenRunAsync(final Runnable action, final Executor executor) {
                return widen(boxed.thenRunAsync(action, executor));
            }

            @Override
            public <U, V> CompletableFutureKind<V> thenCombine(final CompletionStage<? extends U> other,
                                                         final BiFunction<? super T, ? super U, ? extends V> fn) {
                return widen(boxed.thenCombine(other, fn));
            }

            @Override
            public <U, V> CompletableFutureKind<V> thenCombineAsync(final CompletionStage<? extends U> other,
                                                              final BiFunction<? super T, ? super U, ? extends V> fn) {
                return widen(boxed.thenCombineAsync(other, fn));
            }

            @Override
            public <U, V> CompletableFutureKind<V> thenCombineAsync(final CompletionStage<? extends U> other,
                                                              final BiFunction<? super T, ? super U, ? extends V> fn, final Executor executor) {
                return widen(boxed.thenCombineAsync(other, fn, executor));
            }

            @Override
            public <U> CompletableFutureKind<Void> thenAcceptBoth(final CompletionStage<? extends U> other,
                                                            final BiConsumer<? super T, ? super U> action) {
                return widen(boxed.thenAcceptBoth(other, action));
            }

            @Override
            public <U> CompletableFutureKind<Void> thenAcceptBothAsync(final CompletionStage<? extends U> other,
                                                                 final BiConsumer<? super T, ? super U> action) {
                return widen(boxed.thenAcceptBothAsync(other, action));
            }

            @Override
            public <U> CompletableFutureKind<Void> thenAcceptBothAsync(final CompletionStage<? extends U> other,
                                                                 final BiConsumer<? super T, ? super U> action, final Executor executor) {
                return widen(boxed.thenAcceptBothAsync(other, action, executor));
            }

            @Override
            public CompletableFutureKind<Void> runAfterBoth(final CompletionStage<?> other, final Runnable action) {
                return widen(boxed.runAfterBoth(other, action));
            }

            @Override
            public CompletableFutureKind<Void> runAfterBothAsync(final CompletionStage<?> other, final Runnable action) {
                return widen(boxed.runAfterBothAsync(other, action));
            }

            @Override
            public CompletableFutureKind<Void> runAfterBothAsync(final CompletionStage<?> other, final Runnable action,
                                                           final Executor executor) {
                return widen(boxed.runAfterBothAsync(other, action, executor));
            }

            @Override
            public <U> CompletableFutureKind<U> applyToEither(final CompletionStage<? extends T> other,
                                                        final Function<? super T, U> fn) {
                return widen(boxed.applyToEither(other, fn));
            }

            @Override
            public <U> CompletableFutureKind<U> applyToEitherAsync(final CompletionStage<? extends T> other,
                                                             final Function<? super T, U> fn) {
                return widen(boxed.applyToEitherAsync(other, fn));
            }

            @Override
            public <U> CompletableFutureKind<U> applyToEitherAsync(final CompletionStage<? extends T> other,
                                                             final Function<? super T, U> fn, final Executor executor) {
                return widen(boxed.applyToEitherAsync(other, fn, executor));
            }

            @Override
            public CompletableFutureKind<Void> acceptEither(final CompletionStage<? extends T> other,
                                                      final Consumer<? super T> action) {
                return widen(boxed.acceptEither(other, action));
            }

            @Override
            public CompletableFutureKind<Void> acceptEitherAsync(final CompletionStage<? extends T> other,
                                                           final Consumer<? super T> action) {
                return widen(boxed.acceptEitherAsync(other, action));
            }

            @Override
            public CompletableFutureKind<Void> acceptEitherAsync(final CompletionStage<? extends T> other,
                                                           final Consumer<? super T> action, final Executor executor) {
                return widen(boxed.acceptEitherAsync(other, action, executor));
            }

            @Override
            public CompletableFutureKind<Void> runAfterEither(final CompletionStage<?> other, final Runnable action) {
                return widen(boxed.runAfterEither(other, action));
            }

            @Override
            public CompletableFutureKind<Void> runAfterEitherAsync(final CompletionStage<?> other, final Runnable action) {
                return widen(boxed.runAfterEitherAsync(other, action));
            }

            @Override
            public CompletableFutureKind<Void> runAfterEitherAsync(final CompletionStage<?> other, final Runnable action,
                                                             final Executor executor) {
                return widen(boxed.runAfterEitherAsync(other, action, executor));
            }

            @Override
            public <U> CompletableFutureKind<U> thenCompose(final Function<? super T, ? extends CompletionStage<U>> fn) {
                return widen(boxed.thenCompose(fn));
            }

            @Override
            public <U> CompletableFutureKind<U> thenComposeAsync(final Function<? super T, ? extends CompletionStage<U>> fn) {
                return widen(boxed.thenComposeAsync(fn));
            }

            @Override
            public <U> CompletableFutureKind<U> thenComposeAsync(final Function<? super T, ? extends CompletionStage<U>> fn,
                                                           final Executor executor) {
                return widen(boxed.thenComposeAsync(fn, executor));
            }

            @Override
            public CompletableFutureKind<T> exceptionally(final Function<Throwable, ? extends T> fn) {
                return widen(boxed.exceptionally(fn));
            }

            @Override
            public CompletableFutureKind<T> whenComplete(final BiConsumer<? super T, ? super Throwable> action) {
                return widen(boxed.whenComplete(action));
            }

            @Override
            public CompletableFutureKind<T> whenCompleteAsync(final BiConsumer<? super T, ? super Throwable> action) {
                return widen(boxed.whenCompleteAsync(action));
            }

            @Override
            public CompletableFutureKind<T> whenCompleteAsync(final BiConsumer<? super T, ? super Throwable> action,
                                                        final Executor executor) {
                return widen(boxed.whenCompleteAsync(action, executor));
            }

            @Override
            public <U> CompletableFutureKind<U> handle(final BiFunction<? super T, Throwable, ? extends U> fn) {
                return widen(boxed.handle(fn));
            }

            @Override
            public <U> CompletableFutureKind<U> handleAsync(final BiFunction<? super T, Throwable, ? extends U> fn) {
                return widen(boxed.handleAsync(fn));
            }

            @Override
            public <U> CompletableFutureKind<U> handleAsync(final BiFunction<? super T, Throwable, ? extends U> fn,
                                                      final Executor executor) {
                return widen(boxed.handleAsync(fn, executor));
            }

            @Override
            public CompletableFuture<T> toCompletableFuture() {
                return boxed.toCompletableFuture();
            }

            /* (non-Javadoc)
             * @see java.lang.Object#toString()
             */
            @Override
            public String toString() {
                return "CompletableFutureKind [" + boxed + "]";
            }

            /* (non-Javadoc)
             * @see java.lang.Object#hashCode()
             */
            @Override
            public int hashCode() {
                final int prime = 31;
                int result = 1;
                result = prime * result + ((boxed == null) ? 0 : boxed.hashCode());
                return result;
            }

            /* (non-Javadoc)
             * @see java.lang.Object#equals(java.lang.Object)
             */
            @Override
            public boolean equals(Object obj) {
                if (this == obj)
                    return true;
                if (obj == null)
                    return false;
                if (!(obj instanceof  CompletionStage))
                    return false;
                CompletionStage other = ( CompletionStage) obj;
                if (boxed == null) {
                    if (other != null)
                        return false;
                } else if (!boxed.equals(other))
                    return false;
                return true;
            }


        }
    }
}
