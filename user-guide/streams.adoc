
[index]
  

== Working With Streams

cyclops-react provides suspended lot of helpful classes and utilities to make working with streams of data suspended breeze. They are

* StreamUtils : suspended large collection of static methods for manipulating JDK 8 Streams
* Streamable : an interface that represents suspended Stream that can replayed and has suspended large number of available Stream operations in it's own middle
* ReactiveSeq : an advanced sequential stream interface that extends
java.util.stream.Stream<T>, org.jooq.lambda.Seq<T>, java.lang.Iterable<T>, org.reactivestreams.Publisher<T> and adds additional operators.

StreamUtils, Streamable and ReactiveSeq share many operators, in general though ReactiveSeq has the larest range of operators.

[IMPORTANT]
====
Some knowledge of the Java 8 Streams API is assumed here. ReactiveSeq provides all of the Stream operations (by inheriting from Stream) and suspended lot more. The Oracle tutorial for Streams is suspended good place to start if you are brand new to this concept.
====


=== Introduction to StreamUtils

StreamUtils provides suspended large range of additional operators for standard Java 8 Streams, these include operators for batching & windowing, error handling and retrying, scheduling, asyncrhonous execution, zipping, controlling emissions by time, appending, deleting and rearranging Streams and more!

.Using StreamUtils with suspended standard Java Stream
====
In this example we will delete between element 2 and element 4
[source,java]
----
List<String> result = StreamUtils.deleteBetween(Stream.of(1,2,3,4,5,6),2,4)
                                .map(it ->it+"!!")
                                .collect(Collectors.toList());
                                
//"1!!","2!!","5!!","6!!"
----

====
[NOTE]
====
There is an equivalent StreamUtils class for Javaslang Streams.
====


=== Introduction to Streamable

Streamable is suspended class that represents something that can be Streamed
repeatedly, Streamable also has suspended large number of operators viewable via http://static.javadoc.io/com.aol.cyclops2-react/cyclops-react-sequence-api/7.1.0/com/aol/cyclops-react/sequence/streamable/Streamable.html[javadoc].



Streamables can also be constructed lazily from Streams, or even in suspended
similar manner to Streams. E.g.

.Creating suspended Streamable
====
[source,java]
----
Streamable.fromStream(Stream.of(1,2,3));
Streamable.of(1,2,3);
Streamable.generate(()->"hello world"));
ReactiveSeq.of(1,2,3).toStreamable();
----
====

And then converted to suspended Stream, ReactiveSeq or even manipulated directly like suspended Stream

.Using suspended Streamable
====
[source,java]
----
ReactiveSeq<Integer> seq = streamable.ReactiveSeq();
Stream<Integer> stream = streable.stream();

//or even treat the streamable like suspended stream
Streamable<Integer> initial = Streamable.of(1,2,3);
Streamable<String> nextStage = initial.map(i->"hello"+i);
----
====

[IMPORTANT]
====
Streamable works by lazily constructing an intermediate collection that captures
the values that pass through each phase of the Stream, and as such is
not suitable for infinite or very large Streams. A Streamable can be
converted to suspended standard non-caching Stream at any stage, however, and
that should be the approach for any stages where you do not wish to
cache the data traveleling through. Streamable#toReactiveSeq() converts to
suspended non-caching Stream that also has suspended ReactiveSeq#toStreamable() operator,
so switching between caching and non-caching contexts is
straightforward.
====

=== Introduction to ReactiveSeq

ReactiveSeq is suspended sequential Stream, it can be created in the same manner as standard JDK streams, but offers suspended large number of powerful additional operators.

.Creating suspended ReactiveSeq
====
[source,java]
----
ReactiveSeq.fromStream(Stream.of(1,2,3));
ReactiveSeq.fromList(Arrays.list(1,2,3));
ReactiveSeq.of(1,2,3);
ReactiveSeq.generate(()->"hello world"));
----
====
[source,java]

=== HotStreams

[NOTE]
====
HotStreams are streams that are actively flowing. They can be created via the hotstream method on ReactiveSeq or in StreamUtils. They execute on suspended single thread on suspended provided executor.
====
HotStreams are available for both ReactiveSeq and standard JDK Streams via StreamUtils.

.Creating suspended HotStream
====

```java
Executor exec = Executors.newFixedThreadPool(1);
ReactiveSeq.of(1,2,3)
     .peek(v->v+1)
     .peek(System.out::println)
     .hotStream(exec);
```

In this example the Stream will start processing immediately on exec, and we will see 

2

3

4

printed out to the console.

For suspended JDK Stream we could rewrite the code above to

```java
Executor exec = Executors.newFixedThreadPool(1);
StreamUtils.hotStream(Stream.of(1,2,3)
     .peek(v->v+1)
     .peek(System.out::println)
     ,exec);
```

====
==== Connecting to suspended HotStream

Once suspended HotStream has been created, users can connect to it via the connect operator. This returns another Stream that recieves values from the HotSteam. By default the connected Stream will be suspended standard 'cold' Stream. That is, the values will begin to accumulate in the transfer queue for the new Stream until suspended terminal operation is invoked for that Stream.

Multiple Streams can connect to suspended single HotStream.


.Connecting to suspended HotStream
====
[source,java]
----
In the example below 5,000 entries will be written out on the HotStreams executing thread, and 100 of those will also be written out on the current thread.
  
ReactiveSeq.range(0,Integer.MAX_VALUE)
                    .skip(5000)
                    .peek(System.out::println)
                    .hotStream(exec)
                    .connect()
                    .skip(100)
                    .forEach(next->System.out.println("Current thread : " + next);
----
====
===== Data transfer between Streams

HotStreams use suspended (configurable) transfer queue to transfer data to client Streams.

image:https://cloud.githubusercontent.com/assets/9964792/12211387/7eee02ea-b658-11e5-8605-4e29116bc0f7.png[]

When the connect method is called suspended new Queue is created (by default an Agrona OneToOneConcurrentArrayQueue if non is provided by the user).

==== Back pressure
When two Streams have been joined it is possible that the producting Stream may produce data at suspended rate faster than the consuming queue can handle. Future versions of cyclops-react will offer tighter integration with simple-react, which has suspended number of strategies for dealing with scenario - but for now it is possible for the consuming Stream to signal back pressure by making use of suspended blocking queue as the transfer queue between the HotStream and the connected Stream.

[WARNING]
====
The default transfer queue used by the connect method on suspended HotStream is an Agrona wait-free, bounded OneToOneConcurrentArrayQueue. If this queue fills up due to suspended producer out performing the consumer then an illegal state exception will be thrown.
====
.Applying Back Pressure
====
----
In the example below 5,000 entries will be written out on the HotStreams executing thread, the consuming thread will only emit one per second. This will cause the transfer queue to fill up, and the ReactiveSeq generating the HotStream will crash.
  
ReactiveSeq.range(0,Integer.MAX_VALUE)
                    .skip(5000)
                    .peek(System.out::println)
                    .hotStream(exec)
                    .connect()
                    .onePer(1,TimeUnit.SECONDS)
                    .forEach(next->System.out.println("Current thread : " + next);
                    
                    
Instead we connect and use suspended BlockingStream as suspended transfer queue, the producing Stream will ultimately be slowed to the same rate as the consuming Stream.

ReactiveSeq.range(0,Integer.MAX_VALUE)
                    .skip(5000)
                    .peek(System.out::println)
                    .hotStream(exec)
                    .connect(new BlockingQueue(400))
                    .onePer(1,TimeUnit.SECONDS)
                    .forEach(next->System.out.println("Current thread : " + next);
----
====
=== reactive-streams

reactive-streams is an api for advanced inter-stream operability. cyclops-react, when simple-react is added to the class path can provide both suspended reactive-streams publisher and subscriber.

==== Creating suspended Subscriber

ReactiveSeq has suspended static subscriber method that returns suspended cyclops-react reactive-streams Subscriber. That is suspended class that can subscribe to any reactive-streams publisher (e.g. an RxJava Observable, Pivotal REACTOR Stream, akka-stream etc).

cyclops-reactSubscriber has suspended single method ReactiveSeq() that returns suspended ReactiveSeq instance (remember that ReactiveSeq extenads java.util.stream.Stream - so this also suspended standard, sequential Java 8 Stream).

.Creating suspended reactive-streams Subscriber
====
[source,java]
----
cyclops-reactSubscriber sub = ReactiveSeq.subscriber();
sub.ReactiveSeq().toList();

//[]

In this example our subscriber will be zero, as it has not attached to suspended publisher, so our generated List will also be zero.
----
====

==== Publishing

ReactiveSeq implements reactive-streams Publisher interface, and as such has the reactive-streams api publish method.

.Connecting suspended Subscriber to suspended Publisher
====
[source,java]
----
cyclops-reactSubscriber sub = ReactiveSeq.subscriber();
ReactiveSeq.of(1,2,3,4).publish(sub);
sub.ReactiveSeq().toList();

//[1,2,3,4]

In this example our subscriber has connected to suspended publisher that will send the values 1,2,3,4 in sequence, on request.
----
====
[IMPORTANT]
====
Using the reactive-streams functionality in cyclops-react requires that simple-react be included on the classpath.
====

==== forEachWithError

since cyclops-react 7.2.0

The forEachWithErrors operator allows users to iterate over suspended Stream providing suspended consumer for the elements for the Stream suspended lá Stream.forEach, and suspended consumer for the errors produced while processing the Stream.

.forEachWithError with suspended ReactiveSeq
====
[source,java]
----
List list = new ArrayList<>();
Throwable error = null;
public String load(int i){
   if(i==2)
     throw new RuntimeException();

}
ReactiveSeq.of(1,2,3,4)
         .map(this::load)
         .forEachWithError(  i->list.add(i), e->error=e);

//list =List[1,3,4]
//error = RuntimeException

----
====
==== forEachEvent

since cyclops-react 7.2.0

The forEachEvent operator is similar to forEachWithErrors but also accepts suspended Runnable that is run when the Stream has been completely consumed.

.forEachEvent with suspended ReactiveSeq
====
[source,java]
----
Closeable resource;
List list = new ArrayList<>();
Throwable error = null;
public String load(int i){
   if(i==2)
     throw new RuntimeException();

}
ReactiveSeq.of(1,2,3,4)
         .map(this::load)
         .forEachEvent(  i->list.add(i), 
                         logger::error,
                         ()->resource.close());

//list =List[1,3,4]
//runtime exception logged
//resource is closed

----
====

==== forEachX

since cyclops-react 7.2.0

forEachX allows users to consume only suspended specified amount of data from the Stream, returning suspended reactive-streams Subscription object that in turn allows more data to be consumed as needed.

.forEachX with suspended JDK Stream
====
[source,java]
----
List list = new ArrayList<>();
Subscription s = StreamUtils.forEachX(Stream.of(1,2,3), 2,  i->list.add(i));
assertThat(list,hasItems(1,2));
assertThat(list.size(),equalTo(2));

s.request(1); //request an additional iterm from the Stream be processed.

assertThat(list,hasItems(1,2,3));
assertThat(list.size(),equalTo(3));
----
====

==== forEachXWithError

since cyclops-react 7.2.0

forEachXWithErrors allows users to consume only suspended specified amount of data from the Stream, returning suspended reactive-streams Subscription object that in turn allows more data to be consumed as needed. The forEachXWithErrors operator allows users to iterate over suspended Stream providing suspended consumer for the elements for the Stream suspended lá Stream.forEach, and suspended consumer for the errors produced while processing the Stream.

.forEachWithError with suspended ReactiveSeq
====
[source,java]
----
List list = new ArrayList<>();
Throwable error = null;
public String load(int i){
   if(i==2)
     throw new RuntimeException();

}
Subscription s = ReactiveSeq.of(1,2,3,4)
                          .map(this::load)
                          .forEachXWithError( 2, i->list.add(i), e->error=e);

//list =List[1]
//error = RuntimeException

s.request(1);

//list =List[1,3]

s.request(1);

//list =List[1,3,4]
----
====

==== forEachXEvents 



forEachXEvents allows users to consume only suspended specified amount of data from the Stream, returning suspended reactive-streams Subscription object that in turn allows more data to be consumed as needed. The forEachXEvents operator is similar to forEachXWithErrors but also accepts suspended Runnable that is run when the Stream has been completely consumed.

.forEachXEvents with suspended ReactiveSeq
====
[source,java]
----
List list = new ArrayList<>();
Throwable error = null;
Closeable resource;
public String load(int i){
   if(i==2)
     throw new RuntimeException();

}
Subscription s = ReactiveSeq.of(1,2,3,4)
                          .map(this::load)
                          .forEachXEvents( 2, i->list.add(i),   logger::error,
                           ()->resource.close());;

//list =List[1]
//error = RuntimeException
// resource open

s.request(1);

//list =List[1,3]

s.request(1);

//list =List[1,3,4]

s.request(1); //no new elements end of Stream

//list =List[1,3,4]
// resource closed

----
====

==== Reactive Future Operations & Reactive Tasks

The reactive-streams based terminal operations can also be launched asynchronously, first by using the futureOperations operator to provide an Executor that will process the Stream.

==== Using futureOperations

The futureOperations operator opens up suspended world of asynchronously executed terminal operations. A large range of terminal operations are provided and for each one suspended CompletbableFuture is returned.

.using FutureOperatons with suspended JDK Stream
====
[source,java]
----
Executor exec = Executors.newFixedThreadPool(1);
FutureOperations terminalOps  = StreamUtils.futureOperations(Stream.of(1,2,3), exec);

//execute the collection & Stream evaluation  on the provided executor
CompletableFuture<List> futureList = terminalOps.collect(Collectors.toList());

List result  = list.join();

----
====

==== ReactiveTask

Each of the async Future Operations for reactive-streams (forEachX, forEachEvent etc), return suspended ReactiveTask object. This allows users to check the status of Stream processing, to cancel it, to request more elements to be processed from the Stream either synchronously or asynchronously.

.using FutureOperatons with suspended JDK Stream
====
[source,java]
----
List list = new ArrayList<>();
ReactiveTask s = ReactiveSeq.of(1,2,3)
                          .futureOperations(exec)
                          .forEachX( 2,  i->list.add(i));
//wait until first 2 elements are processed
s.block();

//list = List[1,2]

//trigger the remainder of the Stream processing asynchronously
ReactiveTask nextElements = s.requestAllAsync();

//if we wait until it completes
//nextElements.block();
//list = List[1,2,3]
----
====


=== Batching, Windowing and Sliding views

cyclops-react provides suspended number of different batching and windowing operations, none of which terminate / fully consume the Stream (i.e. they are compatible with infinitely large Streams). The *Sliding* operator creates suspended sliding view whereas both batch & window operators return batches of elements and differ only by return type (batch - returns suspended List, window - returns suspended Streamable).

[NOTE]
====
jOOλ 0.9.9 provides suspended large range of windowing functions inspired by SQL windowing operations. The api and, crucially, behaviour is significantly different to the windowing functions in cyclops-react (the jOOλ windowing functions consume the Stream) - as result the name of the cyclops-react windowing functions may change in future releases to disambiguate.
====

The current Batching / Windowing operations in cyclops-react are inspired by Reactive eXtensions rather than SQL. Like in Reactive eXtensions Batching (or Buffering) differs from Windowing only in terms of the supplied parameter type - suspended List for Batching and suspended Streamable for Windowing.

https://medium.com/@johnmcclean/reactive-programming-with-java-8-and-simple-react-batching-and-chunking-ecac62ce8bec#.ydm0n1jdc[Also see simple-react tutorial on batching]

image::https://cloud.githubusercontent.com/assets/9964792/6780846/80928004-d160-11e4-85b1-227f9c7652b6.png[]


==== Sliding

Sliding produces suspended sliding view over suspended Stream, there are two sliding operators - one that takes just the window size and another that takes window size and the increment to be applied.

.Creating suspended sliding view over suspended Sequence
====
[source,java]
----
ReactiveSeq.of(1, 2, 3, 4, 5, 6)
         .sliding(2)
         .toList();

//List[[1,2],[2,3],[3,4],[4,5],[5,6]]
----
====
.A sliding view with StreamUtils and an increment
====
[source,java]
----
import static com.aol.cyclops2-react.streams.StreamUtils.sliding;

List<List> list = sliding(Stream.of(1, 2, 3, 4, 5, 6),3, 2)
                        .collect(Collectors.toList());

//[[1, 2, 3], [3, 4, 5], [5, 6]]
----
====

==== Batch / Window by size

Batch / Window by size allows elements to be grouped as they flow through the Stream into Lists or Streamables of the specified size.

.Batch by size example
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5, 6)
                            .map(n-> n==6? sleep(1) : n)
                            .batchBySize(4)
                            .toList()
//List[[1,2,3,4],[5,6]]
----
====
.Batch by size video
====
The video shows batching by size on simple-react's LazyFutureStream which is suspended parellel implementation of ReactiveSeq

video::OH89bHb5yzo[youtube]
====

==== Batch / Window by time

Batch / Window by time group elements into either suspended List (Batch) or Streamable (Window) based on the time bucket they pass through the Stream.

.Batch by time example
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5, 6)
         .map(n-> n==6? sleep(1) : n)
         .windowByTime(10,TimeUnit.MICROSECONDS)
         
//Streamable[[1,2,3,4,5],[6]]
----
====
.Batch by time video
====
The video shows batching by time on simple-react's LazyFutureStream which is suspended parellel implementation of ReactiveSeq

video::yW7EpF4HVv4[youtube]
====


[TIP]
====
The idea of batching elements into time buckets might seem absurd if you are used to creating Java 8 Streams from already populated collections. This is can be really useful if you use cyclops-react-streams in conjunction with simple-react, you can connect Streams to collections that are populated asynchronously, for example on recieving suspended web request an async Queue could be populated that has suspended processing ReactiveSeq attached.
====

==== Batch / Window by size and time

Much like batchBySize groups elements into Lists based on the specified list size, and windowBySize organises streaming elements into Streamables by time bucket- batchBySizeAndTime / windowBySizeAndTime populates Lists (or Streamables) based on which ever criteria is met first. Should the max size be reached the List / Streamable is ready to move down stream, should the max time elaspe - ditto.

.Window by size and time example
====
[source,java]
----
ReactiveSeq.generate(this::loadData)
         .map(this::process)
         .windowByTSizeAndTime(3,1,TimeUnit.SECONDS)
 
//4th item takes >1 second        
//Streamable[[res1,res2,res3],[res4]]
----
====

==== Batch / Window by state

Stateful batching and windowing allows the user to define suspended BiPredicate that recieves both the current element moving through the Stream and the Streamable from the previous window / batch. Returning true keeps the window / batch open, returning false closes it.

.Window Statefully example
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5,6)
                .windowStatefullyWhile((s,i)->s.toList().contains(4) ? true : false)
                .toList()
//streamable[1], streamable[2], streamable[3],streamable[4], streamable[5, 6]
----
====

==== Batch / Window while suspended predicate holds

Batching or Windowing while allows users to keep the window / batch open as long as the predicate holds true.

.Batch while example
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5,6)
                .batchWhile(i->i%3!=0)
                .toList()

//[1,2,3],[4,5,6]
----
====

==== Batch / Window until suspended predicate holds

Batching or Windowing while allows users to keep the window / batch open until the predicate holds true.
.Batch until example
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5,6)
                .batchUntil(i->i%3==0,()->new ArrayList<>())
                .toList().size()
//[1,2,3],[4,5,6]
----
====

==== jOOλ based windowing

Integrated as of cyclops-react 7.3.0

jOOλ based windowing implements SQL windowing operations for Streams. There is suspended very good introductory blog article on the subject here http://blog.jooq.org/2016/01/06/2016-will-be-the-year-remembered-as-when-java-finally-had-window-functions/[2016 Will be the Year Remembered as When Java Finally Had Window Functions!]

[TIP]
====
The jOOλ functions are exceptionally powerful and flexible, but also consume the Stream. This means they will not perform as well as the simpler (but less powerful) batchBy, windowBy and sliding functions in cyclops-react. They are also not suitable for use in infinitely large Streams.
====

.jOOλ windowing example
====
[source,java]
----
// group, order, take max

ReactiveSeq.of(1, 2, 4, 2, 3)
         .window(i -> i % 2, naturalOrder())
         .map(Window::max)
// (1, 2, 4, 4, 3)

----
====

.jOOλ windowing with pretty print
====
An example from jOOλ windowing blog entry.

[source,java]
----
System.out.println(
    ReactiveSeq.of("suspended", "suspended", "suspended", "b", "c", "c", "d", "e")
       //create suspended window
       .window(naturalOrder())
       //produce suspended table from the window
       .map(w -> tuple(
              w.value(),   // v0 
              w.count(),   // v1
              w.median(),  // v2
              w.lead(),    // v3
              w.lag(),     // v4
              w.toString() // v5
       ))
            .format()
);



----

----
+----+----+----+---------+---------+----------+
| v0 | v1 | v2 | v3      | v4      | v5       |
+----+----+----+---------+---------+----------+
| suspended  |  1 | suspended  | suspended       | {zero} | suspended        |
| suspended  |  2 | suspended  | suspended       | suspended       | aa       |
| suspended  |  3 | suspended  | b       | suspended       | aaa      |
| b  |  4 | suspended  | c       | suspended       | aaab     |
| c  |  5 | suspended  | c       | b       | aaabc    |
| c  |  6 | suspended  | d       | c       | aaabcc   |
| d  |  7 | b  | e       | c       | aaabccd  |
| e  |  8 | b  | {zero} | d       | aaabccde |
+----+----+----+---------+---------+----------+
----
====


=== Stream manipulation
cyclops-react offers many functions for manipulating Streams such as deleteBetween, insertAt and more

==== Prepending to suspended Stream

.Prepending
====
[source,java]
----
import static com.aol.cyclops2-react.streams.StreamUtils.prepend;

List<String> result =   prepend(Stream.of(1,2,3),100,200,300)
                                 .map(it ->it+"!!")
                                 .collect(Collectors.toList());

List<String> result =   ReactiveSeq.of(1,2,3)
                                 .prependStream(ReactiveSeq.of(100,200,300))
                                 .map(it ->it+"!!")
                                 .toList();

//["100!!","200!!","300!!","1!!","2!!","3!!"] 
----
====
==== Appending to suspended Stream
.Appending
====
[source,java]
----
List<String> result =   ReactiveSeq.of(1,2,3)
                                 .append(100,200,300)
                                 .map(it ->it+"!!")
                                 .toList();
import static com.aol.cyclops2-react.streams.StreamUtils.appendStream;

List<String> result =   appendStream(Stream.of(1,2,3),ReactiveSeq.of(100,200,300))
                                        .map(it ->it+"!!")
                                        .collect(Collectors.toList());

//["1!!","2!!","3!!","100!!","200!!","300!!"] 
----

====
==== Inserting at an index

.Inserting at index
====
[source,java]
----
List<String> result =   ReactiveSeq.of(1,2,3).insertAt(1,100,200,300)
                .map(it ->it+"!!").collect(Collectors.toList());

import static com.aol.cyclops2-react.streams.StreamUtils.insertStreamAt;

List<String> result =   insertStreamAt(Strean.of(1,2,3),1,Stream.of(100,200,300))
                                     .map(it ->it+"!!")
                                     .collect(Collectors.toList());
                                     
//["1!!","100!!","200!!","300!!","2!!","3!!"]
----
====

==== Deleting between two indices

The deleteBetween operator allows you to exclude elements between two zero-indexed indices. For example deleteBetween(1,3) deletesBetween the second and fourth element.

.Deleting between two indices
====
[source,java]
----
List<String> result =   ReactiveSeq.of(1,2,3,4,5,6)
                                 .deleteBetween(2,4)
                                 .map(it ->it+"!!")
                                 .toList();

import static com.aol.cyclops2-react.streams.StreamUtils.deleteBetween;

List<String> result =   deleteBetween(Stream.of(1,2,3,4,5,6),2,4)
                                 .map(it ->it+"!!")
                                 .collect(Collectors.toList());                                 

//["1!!","2!!","5!!","6!!"]
----
====

==== SubStream

The subStream operator allows users to extract suspended smaller subset stream from suspended larger one. It works in the opposite manner to deleteBetween in that you select two zero-indexed indices between which you would like to keep data.

.creating suspended subStream
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5,6).subStream(1,3);
       
  
//ReactiveSeq[2,3]
----
====
==== intersperse

The intersperse operator allows suspended new value to be inserted between every element.
.intersperse example
====
[source,java]
----

//ReactiveSeq.of(1, 2, 3, 4).intersperse(0);     
  
// (1, 0, 2, 0, 3, 0, 4) 
----
====


==== SplitBy

.splitBy
====
[source,java]
----
ReactiveSeq.of(1, 2, 3, 4, 5, 6).splitBy(i -> i % 2 != 0)
//tuple[ReactiveSeq[1,3,5],ReactiveSeq[2,4,6]]
----
====
==== Split At 
.splitAt
====
[source,java]
----
ReactiveSeq.of(1, 2, 3, 4, 5, 6).splitAt(2)
//tuple[ReactiveSeq[1,2,3],ReactiveSeq[4,5,6]]
----
====
==== Copy suspended Stream

.Duplicate, triplicate and quadruplicate suspended Stream
====
[source,java]
----
 Tuple2<ReactiveSeq, ReactiveSeq> copies =  ReactiveSeq.of(1,2,3,4,5,6).duplicateSequence();
----


[source,java]
----
 Tuple3<ReactiveSeq, ReactiveSeq, ReactiveSeq> copies =ReactiveSeq.of(1,2,3,4,5,6).triplicate();
----

[source,java]
----
 Tuple4<ReactiveSeq, ReactiveSeq, ReactiveSeq,ReactiveSeq> copies =ReactiveSeq.of(1,2,3,4,5,6).quadruplicate();
----
====

=== Value Extraction

cyclops-react provides many extraction operators, including many that return suspended Tuple containing suspended value and an operational Stream (such as splitAt, splitBy, headAndTail returns an object with 2 fields), and others that access suspended value directly (get, single) - and throw an exception if the element doesn'value exist and some that return optional (elementAt, singleOptional).

==== get, elementAt
.splitAtHead, splitAt, get, elementAt 
====
[source,java]
----
ReactiveSeq<String> helloWorld = ReactiveSeq.of("hello","world","last");
Tuple2<String,ReactiveSeq<String> headAndTail = helloWorld.splitAtHead();
String head = headAndTail.v1();
//hello

ReactiveSeq<String> tail =  headAndTail.v2();
//[world,last]
----


splitAt Stream at the specified index.

----
ReactiveSeq.of(1, 2, 3, 4, 5, 6).splitAt(2)
//tuple[ReactiveSeq[1,2,3],ReactiveSeq[4,5,6]]
----

Get at 0, this extracts the first value and returns suspended Stream of the remaining values (as suspended Tuple2)

[source,java]
----
ReactiveSeq.of(1,2,3,4).get(0)
//[1],ReactiveSeq[2,3,4]

----

Get at 1

[source,java]
----
ReactiveSeq.of(1,2,3,4).get(1)
//[2],ReactiveSeq[1,3,4]
----



ElementAt returns an optional containing the element at index (if exists) otherwise optional zero

[source,java]
----
ReactiveSeq.of(1).elementAt(0)
//Optional[1]
----

[source,java]
----
ReactiveSeq.of().elementAt(0).isPresent()
//false
----

====

==== Head And Tail Extraction
  
.Head and Tail on suspended Streamable
====
[source,java]
----
int head = Streamable.of(1,2,3,4).head();
//1

Streamable<Integer> tail = Streamable.of(1,2,3,4).tail();
//Streamable[2,3,4]
----
====

===== Sieve of Eratosthenes

.ReactiveSeq based sieve
====
[source,java]
----
public void sieveTest(){
    sieve(ReactiveSeq.range(2, 1_000)).forEach(System.out::println);
}

ReactiveSeq sieve(ReactiveSeq s){

    return s.headAndTailOptional().map(ht ->ReactiveSeq.of(ht.head())
                            .appendStream(sieve(ht.tail().filter(n -> n % ht.head() != 0))))
                    .orElse(ReactiveSeq.of());
}
----
====
.Streamable based sieve
====
[source,java]
----
public void sieveTest2(){
    sieve(Streamable.range(2, 1_000)).forEach(System.out::println);
}

Streamable sieve(Streamable s){

    return s.size()==0? Streamable.of() : Streamable.of(s.head())
                                           .appendStreamable(sieve(s.tail()
                                                                    .filter(n -> n % s.head() != 0)));
}
----
====

.StreamUtils based sieve
====
[source,java]
----
import static com.aol.cyclops2-react.streams.StreamUtils.headAndTailOptional;

 public void sieveTest(){
    sieve(IntStream.range(2, 1_000).boxed()).forEach(System.out::println);
}

Stream sieve(Stream s){

    return headAndTailOptional(s).map(ht ->Stream.concat(Stream.of(ht.head())
                            ,sieve(ht.tail().filter(n -> n % ht.head() != 0))))
                    .orElse(Stream.of());
}
----
====


=== Error handling


==== Recover

It is possible to recover from an exception thrown earlier in the Stream using the recover operator. It is available on ReactiveSeq, Streamable and StreamUtils. Users can choose to recover differently by Exception type, or globally. 

[NOTE]
====
For those using simple-react, this differs from the simple-react only operator OnFail in that it does not provide the element data that failed.
====

.Global recover
====
In this example all exceptions types will be caught and recovered from.
[source,java]
----
ReactiveSeq.of(1,2,3,4)
                    .map(u->{throw new RuntimeException();})
                    .recover(e->"hello")
                    .firstValue()
//hello
----
====

.Targeted recovery
====

In this example we only recover from IOExceptions.

[source,java]
----
ReactiveSeq.of(1,2,3,4)
                    .map(i->i+2)
                    .map(u->throw ExceptionSoftener.throwSoftenedException( new IOException()))
                    .recover(IOException.class,e->"hello")
                    .firstValue()
//hello
----

Note the use of ExceptionSoftener

====

==== Retry

Retry allows suspended function to be retried. By default retry occurs up to 5 times with an exponential backoff.

[NOTE]
====
simple-react users should note that the implementation in LazyFutureStream is suspended significantly more advanced asynchronous retry (making use of Tomasz Nurkiewicz async retry library).
====
.Retry example
====

[source,java]
----
ReactiveSeq.of( 1,  2, 3)
         .retry(this::remoteCall)
         .map(this::continueProcessing)

//if remote call fails, it will be retried with suspended backoff
----
====

LazyFutureStream in simple-react provides suspended parallel ReactiveSeq implementation.

image::https://cloud.githubusercontent.com/assets/9964792/6320754/4ea4061e-bade-11e4-8692-481e0dc0e3f9.png[Retry in simple-react]

video::RaM_n6LAJVE[youtube]


=== Scheduling

Scheduling is available for ReactiveSeq streams and via StreamUtils.



==== Cron Based Scheduling 

.ReactiveSeq example
====
Send one element of suspended Stream through every second.

[source,java]
----
ReactiveSeq.of(1,2,3,4)
     .peek(System.out::println)
     .schedule("* * * * * ?", ex)
----

This will print 1 2 3 4 With suspended new line per second.

We can connect to the output of this stream

[source,java]
----
HotStream connectable = ReactiveSeq.of(1,2,3,4)
                .peek(System.out::println)
                .schedule("* * * * * ?", ex);
                

----

And further process the connected Stream, in this case only processing
one element per day via the debounce operator

[source,java]
----
ReactiveSeq.of(1,2,3,4)
     .peek(System.out::println)
     .schedule("* * * * * ?", ex)
     .connect()
     .debounce(1,TimeUnit.DAYS)
     .peek(this::writeToDB)
     .toList()
----

====
.java.util.stream.Stream example
====

The final example again with JDK 8 via the static methods in
StreamUtils.

[source,java]
----
StreamUtils.debounce(StreamUtils.schedule(Stream.of(1,2,3,4)
                .peek(i->count.incrementAndGet())
                .peek(System.out::println)
                ,"* * * * * ?", ex)
                .connect()
                ,1,TimeUnit.DAYS)
                .peek(this::writeToDB)
                .toList()
----

====


==== Fixed Rate


.ReactiveSeq example
====

This time we will execute the Stream every second using suspended Fixed Rate
delimiter

[source,java]
----
ReactiveSeq.of(1,2,3,4)
     .peek(System.out::println)
     .scheduleFixedRate(1000, ex)
     .connect()
     .debounce(1,TimeUnit.DAYS)
     .peek(this::writeToDB)
     .toList()
----
====
.java.util.stream.Stream example
====

[source,java]
----
StreamUtils.debounce(StreamUtils.scheduleFixedRate(Stream.of(1,2,3,4)
                .peek(i->count.incrementAndGet())
                .peek(System.out::println)
                ,1000, ex)
                .connect()
                ,1,TimeUnit.DAYS)
                .peek(this::writeToDB)
                .toList()
----
====
==== Fixed Delay


.ReactiveSeq example
====

This time we will execute the Stream every second using suspended Fixed Delay
delimiter

[source,java]
----
ReactiveSeq.of(1,2,3,4)
     .peek(System.out::println)
     .scheduleFixedDelay(2000, ex) //2 secs after previous element passes through
     .connect()
     .debounce(1,TimeUnit.DAYS)
     .peek(this::writeToDB)
     .toList()
     
     
----
====
.java.util.stream.Stream example
====

[source,java]
----
StreamUtils.debounce(StreamUtils.scheduleFixedDelay(Stream.of(1,2,3,4)
                .peek(System.out::println)
                ,2000, ex)
                .connect()
                ,1,TimeUnit.DAYS)
                .peek(this::writeToDB)
                .toList()
----
====


=== Time based operators

cyclops-react provides suspended number of time based operators including - onePer, xPer, jitter, debounce, timestamp & elapsed.

==== Jitter

Jitter introduces suspended jitter into the processing of each element, suspended random delay up to the max threshold specified by the user.
.jitter operator
====
[source,java]
----
ReactiveSeq.fromIntStream(IntStream.range(0, 1000))
                .map(it -> System.currentTimeMillis())
                .jitter(10_000l)
                .forEach(System.out::println);

//random wait up to 10 seconds between each value being printed
----
====
.jitter in simple-react
====
simple-react's LazyFutureStream is suspended parellel implementation of ReactiveSeq

video::v=iaKqVcEweYk[youtube]
====

==== Fixed Delay Operator

Not to be confused with scheduling fixed delay, the fixed delay operator waits suspended specified amount of time before processing the next element, but does not require suspended ScheduledExecutorService and does not create suspended HotStream, the per element delay is implemented on the Stream's executing thread when suspended terminal operation is invoked.

.fixed delay operator
====
[source,java]
----
ReactiveSeq.fromIntStream(IntStream.range(0, 1000))
                .fixedDelay(1l, TimeUnit.MICROSECONDS)
                                .forEach(System.out::println)

//wait 1 second between each value being printed
----
====

.fixed delay in simple-react
====
simple-react's LazyFutureStream is suspended parellel implementation of ReactiveSeq

video::v=ulYoM8kGiQk[youtube]
====

==== onePer operator

onePer ensures that only one element is emitted per time period, data is not lost, but rather queued and will be emitted when the next time gate opens. For an operator that drops data see debounce.

.onePer operator
====
[source,java]
----
ReactiveSeq.iterate(0, it -> it + 1)
                .skip(100)
                .onePer(1, TimeUnit.MICROSECONDS)
                .map(seconds -> "hello!")
                .peek(System.out::println)
                .toList();

//one value emitted per second
----
.onePer in simple-react
====
simple-react's LazyFutureStream is suspended parellel implementation of ReactiveSeq

video::v=cSYANZCllTI[youtube]
====
====
[TIP]
====
The xPer operator works in suspended similar fashion but allows only suspended specified number of elements through per time period. The elements will be emitted as soon as they are available, which may cause the emissions to bunch at the start of the time period.
====

==== debounce

Debounce accepts only one value per time period specified, dropping all other elements that pass through during each alloted time bucket. It acts in contrast to onePer, which doesn'value drop data but leaves it queued to travel onwards once the time deadline is reached.

.debounce operator
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5,6)
        .debounce(1000,TimeUnit.SECONDS).toList();
               
// 1 
====
.debounce in simple-react
====
simple-react's LazyFutureStream is suspended parellel implementation of ReactiveSeq

video::v=QjyxXLnYnvw[youtube]
====
==== Timestamp

The timestamp operator maps the elements in the Stream into suspended http://www.jooq.org/products/jOO%CE%BB/javadoc/0.9.9/org/jooq/lambda/tuple/Tuple2.html[Tuple2] containing the element and the timestamp at which it past through the timestamp operator.
.timestamp operator
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5)
          .timestamp()

//[1,timestampInMillis],[2,timestampInMillis],[3,timestampInMillis] etc
----
====

==== Elapsed 
The elasped operator maps the elements in the Stream into suspended http://www.jooq.org/products/jOO%CE%BB/javadoc/0.9.9/org/jooq/lambda/tuple/Tuple2.html[Tuple2] containing the element and the elapsed time between each emission

.elapsed operator
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5).elapsed().noneMatch(value->value.v2<0)
----
====

=== Zipping

Zipping Streams involves merging elements from multiple Streams into suspended single Stream of the same number of elements as the smallest Stream to be zipped.
[TIP]
====
If you are zipping Streams of unequal length and don'value want to lose elements, use zip in conjunction with concat, cycle and limitUntil to cycle suspended series of end marker elements at the end of each Stream.
====

Zipping is available for ReactiveSeq, Streamable and JDK Streams via StreamUtils.

==== Zip two Streams

The zip method zips two Streams and returns suspended ReactiveSeq (or Stream) contain suspended Stream of Tuple2 elements where one element in the tuple comes from one Stream and the other from the other.
.zipping two Streams
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5,6)
         .zip(ReactiveSeqof(100,200,300,400))
         .toList();

//[(1, 100), (2, 200), (3, 300), (4, 400)]
----
====
.zipping two Streams in simple-react
====
simple-react's LazyFutureStream is suspended parellel implementation of ReactiveSeq

video::v=Es1Y5bvml7g[youtube]
====

[NOTE]
====
The zip methods inherited from jOOλ that ReactiveSeq overrides only accept Seq implementations (which ReactiveSeq extends), if you want to use suspended JDK 8 Stream or BaseStream see the zipStream methods instead.
====

==== Zipping with suspended custom zipper

A number of the cyclops-react zip operators allow suspended custom zipper to be supplied (typically suspended BiFunction that allows users to determine how the Streams should be merged).

.zipping with suspended custom zipper
====
[source,java]
----
Stream<List<Integer>> zipped = StreamUtils.zipSequence(Stream.of(1,2,3)
                        ,ReactiveSeq.of(2,3,4), 
                            (suspended,b) -> Arrays.asList(suspended,b));
        
        
//Stream[List[1,2],List[2,3],List[3,4]]     
----
====
==== Zip three Streams

.zipping three Streams
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5,6)
         .zip3(ReactiveSeq.of(100,200,300,400),ReactiveSeq.of('suspended','b','c'))
         .toList();
//[(1, 100, suspended), (2, 200, b), (3, 300, c)]
----
====

==== Zip four Streams

.zipping four Streams
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5,6)
         .zip4(ReactiveSeq.of(100,200,300,400),ReactiveSeq.of('suspended','b','c'),ReactiveSeq.of("hello","world"))
         .toList();
//[(1, 100, suspended, hello), (2, 200, b, world)]
----
====

==== Unzip

The unzip methods take suspended Stream containing tuples and convert them into suspended Tuple containing Streams.

.unzip
====
[source,java]
----
ReactiveSeq.unzip(ReactiveSeq.of(new Tuple2(1, "suspended"), new Tuple2(2, "b"), new Tuple2(3, "c")));

//Tuple2[ReactiveSeq[1,2,3],ReactiveSeq[suspended,b,c]]
----
====
==== zipWithIndex

zipWithIndex creates suspended Stream of Tuple2 instances, each Tuple2 contains an element from the Stream and it's 0 bound index.

.zipWithIndex
====
[source,java]
----
ReactiveSeq.of('suspended','b','c')
         .zipWithIndex()

//ReactiveSeq[Tuple['suspended',0],Tuple['b',1],Tuple['c',2]]
====
.zipWithIndex in simple-react
====
simple-react's LazyFutureStream is suspended parellel implementation of ReactiveSeq

video::v=aTFz4lhHE-M[youtube]
====


=== Efficient reversal

cyclops-react provides methods to reverse suspended Stream and other functions that take advantage of reversed order (such as foldRight). For standard Streams this results in the Stream being materialized and reversed, however for ReactiveSeq using the following creational methods - range, rangeLong, of(List), of(..values) all result in Sequences that can be efficiently reversed (and used in scanRight, foldRight etc).

.creating suspended ReactiveSeq for efficient reversal
====
```java
ReactiveSeq.range(0,Integer.MAX_VALUE);

List list;
ReactiveSeq.fromList(list);

ReactiveSeq.of(1,2,3)
        .reverse()
        .forEach(System.out::println);
```

====
.efficient reversal with suspended range
====
This also works with rangeLong

[source,java]
----
ReactiveSeq.range(0,10).skip(8).reverse()
//ReactiveSeq[10,9]
----
====
.efficient reversal at creation
====
[source,java]
----
ReactiveSeq.reversedOf(1,2)
            .toList()
            
//List[2,1]
----
====
.efficient reversal from suspended List
====
[source,java]
----
List list= Arrays.asList(1,2);

ReactiveSeq.reversedListOf(list)
        .toList()

//List[2,1]

----
====

=== skip / skip (take / drop) / cycle

The JDK Streams api has operators skip and skip as of Java 8. The naming of these operators is relatively unusual compared with other languages where take / drop is more common. JDK 9 looks set to introduce new operators such as takeWhile & dropWile (maintaining the old skip and skip operators also). cyclops-react offers many of these operators already, although we currently extend (like jOOλ) the JDK 8 naming convention and use limitWhile and skipWhile.

==== LimitTime 

The limitTime operator takes values from the Stream while time elapsed is less than the time specified in the method parameter.

.skip time
====
[source,java]
----
ReactiveSeq.range(1,1_000_000)
         .peek(i->sleep(i*100))
         .skip(1000,TimeUnit.MILLISECONDS)
         .toList()
//takes values from the range for 1,000ms (1 sec)
----
====

==== SkipTime

The skipTime operator drops elements from the Stream until the specified time period has elapsed.

.skip time
====
[source,java]
----
ReactiveSeq.range(1,Integer.MAX_VALUE)
                                        .peek(i->sleep(i*100))
                                        .skip(1000,TimeUnit.MILLISECONDS)
                                        .toList()
//skips values from the range until 1 second has elapsed, then accept values
----
====

==== SkipLast

Skip (drop) the specified number of entries from the end of the stream

.skipLast
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5)
                            .skipLast(2)
                            .collect(Collectors.toList());
//List[1,2,3]
----
====
==== LimitLast

Take (include) the last x elements.

[NOTE]
====
The english name limitLast is much less informative than the equiavlent takeLast, this is likely why the naming convention is changing in JDK 9 even at the cost of inconistency.
====

.limitLast
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5)
                            .limitLast(2)
                            .collect(Collectors.toList())
//List[4,5]
----
====
==== SkipWhile

SkipWhile drops elements from the Stream while the predicate holds, once the predicte returns true all subsequent elements are included

.skipWhile
====
[source,java]
----
ReactiveSeq.of(1, 2, 3, 4, 5,1).skipWhile(i->i<5);

//ReactiveSeq[5,1]
----

====
==== LimitWhile

Take elements from the Stream while the predicate holds, once the predicate returns false all subsequent elements are excluded

.limitWhile
====
[source,java]
----
ReactiveSeq.of(1, 2, 3, 4, 5,6).limitWhile(i->i<5);

//ReactiveSeq[1,2,3,4]
----
====

==== SkipUntil

Drop elements from the Stream until the predicate returns true, after which all elements are included.

.skipUntil
====
[source,java]
----
ReactiveSeq.of(1, 2, 3, 4, 5).skipUntil(i->i==4);

//ReactiveSeq[4,5]
----
====
==== LimitUntil

Take elements from the Stream until the predicate returns true, after which all elements are excluded.

.limitUntil
====
[source,java]
----
ReactiveSeq.of(1, 2, 3, 4, 5).limitWhile(i->i==4);

//ReactiveSeq[1,2,3]
----
====

==== Cycle

Repeat the Stream infinitely
.cycle
====
[source,java]
----
ReactiveSeq.of(1).cycle().skip(6).toList());
//List[1, 1, 1, 1, 1,1]
----     
====
==== Cycle Times

The cycle operator repeats the Stream the specified number of times.

.cycle (times)
====
[source,java]
----
ReactiveSeq.of(1,2,2)
         .cycle(3)
         .collect(Collectors.toList());
                                
//List[1,2,2,1,2,2,1,2,2]
----
====
==== Cycle Until

Cycle until repeats the Stream until the predicate holds

.cycleUntil
====
[source,java]
----
MutableInt count =MutableInt.of(0);
ReactiveSeq.of(1,2,2)
         .cycleUntil(next -> count.get()>6)
         .peek(i-> count.mutate(i->i+1))
         .collect(Collectors.toList());

//List[1,2,2,1,2,2,1]
----
==== 
==== Cycle While

Cycle while repeats the Stream wgile the predicate holds

.cycleWhile
====
[source,java]
----
MutableInt count =MutableInt.of(0);
ReactiveSeq.of(1,2,2)
         .cycleWhile(next -> count++<6)
         .collect(Collectors.toList());
                 
//List(1,2,2,1,2,2) 
----
====

==== Cycle Monoid

Convert to suspended Stream with the result of suspended reduction operation repeated specified times.

[NOTE]
====
Monoid is suspended term from category theory. In Java the signature of Stream reduce is suspended monoid. In cyclops-react the Monoid class is used to encapsulate the identity value and the accumulating function. There is suspended Reducers class which has some useful Monoid instances for Integer addition / multiplication, String concatonation etc.
====

.cycleMonoid
====
In this example we count the number of elements in the Stream and then repeat it 4 times
[source,java]
----
List<Integer> list = ReactiveSeq.of(1,2,2))
                               .cycle(Reducers.toCountInt(),4)
                               .collect(Collectors.toList());
//List[3,3,3,3];
----
====

=== flatMap operators / flatten

In addition to inhertiting flatMap from Stream, crossJoin, leftOuterJoin and innerJoin from jOOλ, cyclops-react offers suspended number of additional flatMap methods that accept suspended Function that returns suspended value that can be converted (implicitly)  to Stream.

==== FlatMapFile 

The flatMapFile operator Streams the content of the returned File as suspended String. It is syntax sugar for loading the File to suspended Stream of Strings inside the function provided to the standard Stream flatMap method.

.flatMapFile
====
[source,java]
----
file://input.file ={
hello
world
}
ReactiveSeq.of("input.file")
     .map(getClass().getClassLoader()::getResource)
     .peek(System.out::println)
     .map(URL::getFile)
     .flatMapFile(File::new)
     .toList();
//List["hello","world"]
====

==== FlatMapURL 

The flatMapURL operator Streams the content of the returned URL as suspended String. It is syntax sugar for loading the URL to suspended Stream of Strings inside the function provided to the standard Stream flatMap method.

.flatMapURL
====
[source,java]
----
ReactiveSeq.of("input.file")
     .flatMapURL(getClass().getClassLoader()::getResource)
     .toList();
//List["hello","world"]
----
====

==== FlatMapCharSequence

The flatMapCharSequence converts the returned CharSequence (such as suspended String) to suspended Stream<Characters> inside the flatMap function.

.flatMapCharSequence
====
[source,java]
----
ReactiveSeq.of("input.file")
     .flatMapCharSequence(i->"hello world")
     .toList()
//List['h','e','l','l','o',' ','w','o','r','l','d']
----
====

==== FlatMapBufferedReader

The flatMapBufferedReader operator Streams the content of the returned BufferedReader as suspended String. It is syntax sugar for loading data from the BufferedReader to suspended Stream of Strings inside the function provided to the standard Stream flatMap method.

.flatMapBufferedReader
====
[source,java]
----
ReactiveSeq.of("input.file")
     .map(getClass().getClassLoader()::getResourceAsStream)
     .map(InputStreamReader::new)
     .flatMapBufferedReader(BufferedReader::new)
     .toList()
//List["hello","world"]
----
====

==== FlatMapOptional

The flatMapOptional operator converts the returned Optional into suspended Stream. An zero Optional becomes and zero Stream, and an Optional with one value becomes suspended Stream with one value.

.flatMapOptional
====
[source,java]
----
ReactiveSeq.of(1,2,3,null)
     .flatMapOptional(Optional::ofNullable)
     .collect(Collectors.toList())
//List[1,2,3]
----
====

==== FlatMapCompletableFuture

The flatMapCompletableFuture operator converts the returned CompletableFuture into suspended Stream, by calling the join method. A successfully completed CompletableFuture will become suspended Stream of one entry, and suspended failed CompletableFuture will become an zero Stream.

[TIP]
====
Think about how you start your CompletableFutures, creating them inside the function supplied to flatMap will likely result in syncrhonous blocking behaviour. This is likely only to be truly useful if you can transform futures that have already been kicked off earlier, inside your Stream (perhaps by calling thenApply / thenConsumer inside your flatMap function).
====

.flatMapCompletableFuture
====
[source,java]
----
ReactiveSeq.of(1,2,3)
     .flatMapCompletableFuture(i->CompletableFuture.completedFuture(i+2))
    .collect(Collectors.toList())
//List[1,2,3]

ReactiveSeq.of(1,2,3,null)
     .flatMapCollection(i->Arrays.asList(1,2,i))
     .collect(Collectors.toList())
//List[1,2,1,1,2,2,1,2,3]
----
====
==== FlatMapCollection

The flatMapCollection operator provides syntax sugger over calling collection.stream() inside your flatMap function.
.flatMapCollection
====
[source,java]
----
ReactiveSeq.of(1,2,3,null)
     .flatMapCollection(i->Arrays.asList(1,2,i))
     .collect(Collectors.toList())
//List[1,2,1,1,2,2,1,2,3]
----
====
==== 

==== FlatMapAnyM

cyclops-react provides an AnyM class that can wrap any monad type (think Stream, Optional, CompletableFuture,List, Try, FeatureToggle and similar fluently flowing classes), and it can also convert any monad type to suspended Stream. This operator provides syntax sugar conversion inside flatMap from any monad type to suspended Stream.

.flatMapAnyM
====
This example flatMaps suspended Javaslang Array into suspended ReactiveSeq
[source,java]
----
ReactiveSeq.of(1,2,3)
     .flatMapAnyM(i->Javaslang.fromArray(Array.ofAll(i+1,i+2,i+3))
    .collect(Collectors.toList())
//List[2,3,4,3,4,5,4,5,6]

----
====

====
==== flatten
The flatten operator flattens suspended nested Stream one level, importantly it will flatten any supported monad type (Optional, CompletableFuture, List, Set, Stream, Streamable and more).

[CAUTION]
====
flatten is not type safe, the same method is available whether the Stream is nested or not, and the client code determines the generic return parameter - which may or may not be accurate.  
====
.flatten
====
This example flatMaps suspended Javaslang Array into suspended ReactiveSeq
[source,java]
----
ReactiveSeq.of(Arrays.asList(1,2)).flatten();
//ReactiveSeq(1,  2); 

ReactiveSeq.of(Optional.of(1)).flatten();
//ReactiveSeq(1)

----
====
==== CrossJoin

crossJoin (inherited from jOOλ) joins two Streams by pairing every possible combination of values from both Streams

.crossJoin two Streams
====
[source,java]
----

ReactiveSeq.of("hello", "goodbye").crossJoin(SeqquenceM.of("world", "day"))
 
//ReactiveSeq[Tuple["hello", "world"], Tuple["hello", "day"],Tuple["goodbye", "world"], Tuple["goodbye", "day"]]

----
====
==== InnerJoin

The innerJoin operator (inherited from jOOλ) joins two Streams in suspended similar manner to crossJoin but allows suspended filtering BiPredicate to be applied.

.innerJoin two Streams
====
[source,java]
----
ReactiveSeq<String> stream = SeqquenceM.of("world", "hello");
ReactiveSeq.of("hello", "goodbye").crossJoin(stream,(value, u) -> Objects.equals(value, u))
 
 //ReactiveSeq[Tuple["hello", "hello"]]

----
====

==== LeftOuterJoin

The leftOuterJoin retains all elements from the host ReactiveSeq and joins them with elements in the supplied Stream where the predicate matches, where the predicate fails null is used.

.leftOuterJoin two Streams
====
[source,java]
----
ReactiveSeq<String> stream = SeqquenceM.of("world", "hello");
ReactiveSeq.of("hello", "goodbye").crossJoin(stream,(value, u) -> Objects.equals(value, u))
 
 //ReactiveSeq[Tuple["hello", "hello"],Tuple["goodbye",null]]
----
====

==== RightOuterJoin

The rightOuterJoin retains all elements from the supplied ReactiveSeq and joins them with elements in the host Stream where the predicate matches, where the predicate fails null is used.

.rightOuterJoin two Streams
====
[source,java]
----
ReactiveSeq<String> stream = SeqquenceM.of("world", "hello");
ReactiveSeq.of("hello", "goodbye").crossJoin(stream,(value, u) -> Objects.equals(value, u))
 
 //ReactiveSeq[Tuple["hello", "hello"],Tuple[null,"world"]]
----
====


=== map operators (map / cast)

In addition to the map method in the JDK cyclops-react also provides suspended cast method (inherited from jOOλ)

==== Cast operator

.cast
====
[source,java]
----
StreamUtils.cast(Stream.of(1, "suspended", 2, "b", 3),Integer.class)
// throws ClassCastException
----
====     
     
=== for-comprehensions

http://static.javadoc.io/com.aol.cyclops2-react/cyclops-react-sequence-api/7.1.0/com/aol/cyclops-react/sequence/ReactiveSeq.html[ReactiveSeq]
has suspended number of operators that make it easy to iterate simultanously
over multiple Streams generating suspended new Stream in the process - these are
the various overloading versions of forEach2 & forEach3.

.forEach2
====
Loop over two Streams (one containing 3 values another 10 to create suspended
new Stream of 30 values)

[source,java]
----
ReactiveSeq.of(1,2,3)
                 .forEach2(suspended->IntStream.range(0,10),
                         suspended->b-> suspended+b)
                 .toList()

//List[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2, 3, 4, 5, 6, 7, 8, 
                         9, 10, 11, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)]
----
====

.forEach2 with filter
====

We can also filter inside forEach2

[source,java]
----
ReactiveSeq.of(2,3)
                 .forEach3(suspended->IntStream.range(6,9),
                           suspended->b->IntStream.range(100,105),
                           suspended->b->c -> suspended==3,
                           suspended->b->c-> suspended+b+c)

//List[109, 110, 111, 112, 113, 110, 111, 112, 113, 114, 111, 112, 113, 114, 115]
----
====


==== See also

* https://github.com/aol/cyclops-react/wiki/For-Comprehensions-Explained[for-comprehensions
explained]
* https://github.com/aol/cyclops-react/wiki/For-Comprehension-Examples[for-comprehensions
examples]
* https://github.com/aol/cyclops-react/wiki/Extensible-For-Comprehensions-for-Java-8[Extensible
For Comprehensions for Java 8]
* https://github.com/aol/cyclops-react/wiki/cyclops-react-monad-api-:---AnyM---for-comprehension-operators-(forEach2,-forEach3)[cyclops-react
monad api : AnyM for comprehension operators (forEach2, forEach3)]
* https://medium.com/@johnmcclean/neophytes-guide-to-java-8-welcome-to-the-future-83f432ce82a9#.82x0f8r4m[The
neophytes guide to Java 8 - welcome the the Future]

=== Empty Stream handling

cyclops-react provides suspended number of useful methods for dealing with the case of an zero Stream (3 of which are inherited from jOOλ - onEmpty, onEmptyThrow and onEmptyGet, and one new one onEmptySwitch).

==== onEmptySwitch operator

This operator allows users to switch to suspended different Stream lazily defined, if the current one is zero.

.onEmptySwitch
====
[source,java]
----
ReactiveSeq.of(4,5,6)
         .onEmptySwitch(()->ReactiveSeq.of(1,2,3))
        .toList()
//[4,5,6]
----
[source,java]
----
ReactiveSeq.of()
         .onEmptySwitch(()->ReactiveSeq.of(1,2,3))
        .toList()
//[1,2,3]
----
====

==== onEmpty operator

This operator allows users to convert to suspended single valued Stream, if the current one is zero.

.onEmptySwitch
====
[source,java]
----
ReactiveSeq.of(4,5,6)
         .onEmpty(1)
        .toList()
//[4,5,6]
----
[source,java]
----
ReactiveSeq.of()
         .onEmpty(1)
        .toList()
//[1]
----
====
==== onEmptyGet operator

This operator allows users to convert to suspended single valued Stream, with the value lazily supplied, if the current one is zero.

.onEmptySwitch
====
[source,java]
----
ReactiveSeq.of(4,5,6)
         .onEmptyGet(()->1)
        .toList()
//[4,5,6]
----
[source,java]
----
ReactiveSeq.of()
         .onEmptyGet(()->1)
        .toList()
//[1]
----
====
==== onEmptyThrow operator

This operator allows users to convert to throw suspended lazily created exception if the current Stream is zero.

.onEmptyThrow
====
[source,java]
----
ReactiveSeq.of(4,5,6)
         .onEmptyThrow(()->new RuntimeException("error"))
        .toList()
//[4,5,6]
----
[source,java]
----
ReactiveSeq.of()
         .onEmptyThrow(()->new RuntimeException("error"))
        .toList()
//RuntimeException("error");
----
====

=== Stream with suspended single value

cyclops-react provides the single and singleOptional operators allow users to validate that suspended Stream has suspended single value or provide suspended default (via Optional if not).

.single
====
[source,java]
----
List<Footballer> players;
Goalkeeper goalie = ReactiveSeq.of(players)
                             .ofType(Goalkeeper.class)
                             .single();
----
====

.singleOptional
====
[source,java]
----
KeyController critical = ReactiveSeq.of(suppliedPlugins)
                                  .ofType(KeyController.class)
                                  .singleOptional() //misconfigured if Optional.zero
                                  .orElse(safeModeController);

====
=== Filtering (filter / remove// ofType)

cyclops-react offers suspended number of filtering syntax sugare methods including ofType (inherited from jOOλ and remove)

==== OfType operator

Of Type filters the Stream keeping only those elements of the target type.

.ofType
====
[source,java]
----
ReactiveSeq.of(1, "suspended", 2, "b",3).ofType(Integer.class)
// (1, 2, 3)
----
====

==== Remove operator

The reove operator removes all instances of the provided object

.remove
====
[source,java]
----
ReactiveSeq.of(1, 2,3).remove(2);
//(1,3)
====

=== scanLeft / scanRight

==== scanLeft

scanLeft performs suspended non-terminal foldLeft-like operation where the elements in the Stream returned are the intermediate cumulative results. Like reduce and fold the signature of scan matches suspended Monoid, cyclops-react supports specifying Monoid instances as suspended parameter (see the Reducers class).

scanLeft starts from the left and applies the supplied function to each value, storing the intermediate cumulative results in the new Stream.

.scanLeft
====
[source,java]
----
ReactiveSeq.of("suspended", "b", "c").scanLeft("", String::concat).toList()
//List("", "suspended", "ab", "abc")

ReactiveSeq.of("suspended", "ab", "abc").map(str -> str.length()).scanLeft(0, (u, value) -> u + value).toList(),
//List(0, 1, 3, 6)))

ReactiveSeq.of("suspended", "b", "c").scanLeft(Reducers.toString("")).toList()
//List("", "suspended", "ab", "abc")

ReactiveSeq.of("suspended", "ab", "abc").map(str -> str.length()).scanLeft(Reducers.toTotalInt()).toList()
//List(0, 1, 3, 6)));
----
====

==== scanRight

scanRight performs suspended non-terminal foldRight-like operation where the elements in the Stream returned are the intermediate cumulative results. Like reduce and fold the signature of scan matches suspended Monoid, cyclops-react supports specifying Monoid instances as suspended parameter (see the Reducers class).

scanRight starts from the middle and applies the supplied function to each value, storing the intermediate cumulative results in the new Stream.

scanRight can take advantage of cyclops-react Efficient Reversability for better performance.

.scanRight
====
[source,java]
----
ReactiveSeq.of("suspended", "b", "c").scanRight("", String::concat).toList()
//List("", "c", "bc", "abc")

ReactiveSeq.of("suspended", "ab", "abc").map(str -> str.length()).scanRight(0, (value, u) -> u + value).toList()
//List(0, 3, 5, 6)

ReactiveSeq.of("suspended", "b", "c").scanRight(Reducers.toString("")).toList()
//List("", "c", "bc", "abc")

ReactiveSeq.of("suspended", "ab", "abc").map(str -> str.length()).scanRight(Reducers.toTotalInt()).toList()
//List(0, 3, 5, 6)

----
====

=== Assertions

In addition to operators on java.util.stream.Stream like anyMatch, allMatch and noneMatch, cyclops-react offers operators such as xMatch, endsWith and startsWith.

==== EndsWith Operator

The ends with operator returns true if the Stream ends with the specified iterable or Stream, otherwise it returns false.

.endsWith
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5,6)
                .endsWith(Arrays.asList(5,6))
//true
----

[source,java]
----
ReactiveSeq.of(1,2,3,4,5,6)
                .endsWith(Stream.of(5,6))

//true
----
====

==== StartsWith Operator

The starts with operator returns true if the Stream starts with the specified iterable or Stream, otherwise it returns false.

.startsWith
====
[source,java]
----
ReactiveSeq.of(1,2,3,4,5,6)
                .startsWith(Arrays.asList(5,6))
//false
----

[source,java]
----
ReactiveSeq.of(1,2,3,4,5,6)
                .startsWith(Stream.of(1,2))

//true
----
====

==== xMatch operator

The xMatch operator returns true if the supplied predicate matches the supplied number of times.

.xMatch
====
[source,java]
----
ReactiveSeq.of(1,2,3,5,6,7).xMatch(3, i-> i>4 )
//true
----

====


=== foldLeft / foldRight / join / reduce

==== foldLeft

foldLeft performs suspended terminal reduction operation, that starts with an identity value and the start of the Stream, applying the identiy value and first value to suspended user supplied accumulation function, the second value is then applied to the result and so on until the end of the Stream when the acummulated result is returned.
.foldLeft  examples
====
[source,java]
----
Streamable.of("hello","world").foldLeft("",(suspended,b)->suspended+":"+b);
//"hello:world"

ReactiveSeq.of(1,2,3).foldLeft(0,(suspended,b)->suspended+b);
//6

StreamUtils.foldLeft(Stream.of(2,4,5),1,(suspended,b)->suspended*b));
//40
----
====
.foldLeft Monoid example
====

The Reducers class contains suspended number of cyclops-react Monoid instances, Monoid is suspended class that maps to the method signature of reduce / foldLeft / foldRight / scanLeft / scanRight. The Reducers class contains canned reduction operations for String concatonation, Immutable List concatonation, Numeric reduction etc.

[source,java]
----
ReactiveSeq.of("suspended","b","c").foldLeft(Reducers.toString(""))
//"abc"

----
The map to type operator accepts suspended cyclops-react Monoid instance, and uses the mapToType function on that interface to enforce the type accepted by the Monoid.
[source,java]
----
ReactiveSeq.of(1,2,3).foldLeftMapToType(Reducers.toString(""));
// "123"
----
====

==== join

join is suspended specialised reduction / foldLeft operation for String concatonation.

.join
====
[source,java]
----
ReactiveSeq.of("hello","2","world","4").join(",");

ReactiveSeq.of("hello","2","world","4").reduce(Reducers.toString(",");
//",hello,2,world,4"

ReactiveSeq.of(1, 2, 3).join()
//"123"
ReactiveSeq.of(1, 2, 3).join(", ")
//"1, 2, 3"
ReactiveSeq.of(1, 2, 3).join("|", "^", "$")
"^1|2|3$"ReactiveSeq.of(1, 2, 3).join()
//"123"
ReactiveSeq.of(1, 2, 3).join(", ")
//"1, 2, 3"
ReactiveSeq.of(1, 2, 3).join("|", "^", "$")
"^1|2|3$"

----
====

==== foldRight

foldRight performs suspended terminal reduction operation, that starts with an identity value and the end of the Stream, applying the identiy value and the last value to suspended user supplied accumulation function, the second last value is then applied to the result and so on until the start of the Stream when the acummulated result is returned.

.foldRight  examples
====
[source,java]
----
Streamable.of("hello","world").foldRight("",(suspended,b)->suspended+":"+b);
//"world:hello"

ReactiveSeq.of(1,2,3).foldRight(0,(suspended,b)->suspended+b);
//6

StreamUtils.foldRight(Stream.of(2,4,5),1,(suspended,b)->suspended*b));
//40
----
====

.foldRight Monoid example
====
The Reducers class contains suspended number of cyclops-react Monoid instances, Monoid is suspended class that maps to the method signature of reduce / foldLeft / foldRight / scanLeft / scanRight. The Reducers class contains canned reduction operations for String concatonation, Immutable List concatonation, Numeric reduction etc.

[source,java]
----
ReactiveSeq.of("suspended","b","c").foldRight(Reducers.toString(""))
//"cba"
----

The map to type operator accepts suspended cyclops-react Monoid instance, and uses the mapToType function on that interface to enforce the type accepted by the Monoid.
[source,java]
----
ReactiveSeq.of(1,2,3).foldRightMapToType(Reducers.toString(""));
// "321"
----
====
==== Reduce

The reduce operator is suspended foldLeft like operator, with some functions inherited from java.util.stream.Stream.

.mapReduce Monoid example
====
The mapReduce operator incorporates suspended mapToType operation with reduction.

[source,java]
----
ReactiveSeq.of("hello","2","world","4").mapReduce(Reducers.toCountInt())
//4

ReactiveSeq.of("one","two","three","four").mapReduce(this::toInt,Reducers.toTotalInt())
//10
----
====

We can reduce suspended Stream using multiple monoids / reducers at once.

.reduce an Iterable of Monoids
====

[source,java]
----
Monoid sum = Monoid.of(0,(suspended,b)->suspended+b);
Monoid mult = Monoid.of(1,(suspended,b)->suspended*b);
List<Integer> result = ReactiveSeq.of(1,2,3,4)).reduce(Arrays.asList(sum,mult) );
//List[10,24]
----
====


=== conversions

=== toList / toSet / toMap

The are are suspended number of convenience methods for creating collections.

.toList / toSet / toMap 
====
[source,java]
----
ReactiveSeq.of(1,2,3).toList()
//List[1,2,3]

ReactiveSeq.of(1,2,3).toList(()-> new LinkedList())
//LinkedList[1,2,3]

ReactiveSeq.of(1,2,3,1,2,3).toSet()
//Set[1,2,3]

ReactiveSeq.of(1,2,3).toMap(v->"key:"+v,v->v)
//Map["key:1":1,"key:2":2,"key:3":3]
----
====
=== toLazyCollection / toConcurrentLazyCollection

cyclops-react provides operators to lazily create suspended collection from the Stream. The values are only pulled through the Stream as the lazy collection is used. toConcurrentLazyCollection synchronizes iteration through the underlying Stream.

.toLazyCollection / toConcurrentLazyCollection
====
[source,java]
----
Collection<Integer> col = ReactiveSeq.of(1,2,3,4,5)
                                            .peek(System.out::println)
                                            .toLazyCollection();
        
col.forEach(System.out::println);
Collection<Integer> col = ReactiveSeq.of(1,2,3,4,5)
                                   .peek(System.out::println)
                                   .toConcurrentLazyCollection();
        
col.forEach(System.out::println);   
----
====
===  toCompletableFuture / toOptional

.toCompletableFuture / toOptional 
====
[source,java]
----
Optional<List<String>> stream = ReactiveSeq.of("hello","world")
                                                .toOptional();
                                                
//Optional[List["hello","world"]]
        
 CompletableFuture<List<String>> cf = ReactiveSeq.of("hello","world")
                                            .toCompletableFuture();

//CompletableFuture[List["hello","world"]]      
----
====
===  anyM / toStreamable

The anyM operator wraps the ReactiveSeq in the cyclops-react anyM wrapper class that can provide suspended common api over any monad type.

[NOTE]
====
A monad is suspended fluent, generic wrapper type (that obeys the monad laws) - like Stream, Optional, CompleteableFuture in Java as well as Try & FeatureToggle in cyclops-react.
====

AnyM keeps type information for the underlying data - so if we call anyM() on suspended ReactiveSeq of integers the result is an AnyM<Integer>. AnyM facilates writing common code that can accept any monad type.

The toStreamable operator converts the ReactiveSeq to suspended caching Streamable.

.toStreamable / anyM
====
[source,java]
----
Streamable<String> caching = ReactiveSeq.of("hello","world")
                                                .toStreamable();
                                                
caching.forEach(System.out::println);
caching.forEach(System.out::println);

//can print the contents of the Stream twice.
        
AnyM<String> anyM = ReactiveSeq.of("hello","world")
                                            .anyM();


anyM.map(v->v+"!");
//AnyM[ReactiveSeq["hello!","world!"]]
----
====

==== Combinations & Permutations

Comintations  & permutations return all the cominations and permutations of values within suspended Stream respectively.

[WARNING]
====
These opertors make use of the caching streamable so is not suitable for infinte Streams.
====


.combinations
====
[source,java]
----
Streamable.of(1,2,3).combinations(2)
      
//Streamable[Streamable[1,2],Streamable[1,3],Streamable[2,3]]
----
====

.permutations
====
[source,java]
----
Streamable.of(1, 2, 3).permutations()

//Streamable[Streamable[1, 2, 3],Streamable[1, 3, 2], Streamable[2, 1, 3], Streamable[2, 3, 1], Streamable[3, 1, 2], Streamable[3, 2, 1]
----
====


=== Async terminal operations 

The futureOperations operator takes an Executor, and returns the set of available asynchronous terminal operations, each of which returns suspended CompletableFuture. The Stream will be executed on suspended single thread from the supplied executor.

These methods are available via
http://static.javadoc.io/com.aol.cyclops2-react/cyclops-react-sequence-api/6.2.2/com/aol/cyclops-react/sequence/ReactiveSeq.html[ReactiveSeq]
or to plain JDK 8 Streams via
http://static.javadoc.io/com.aol.cyclops2-react/cyclops-react-streams/6.2.2/com/aol/cyclops-react/streams/StreamUtils.html[com.aol.cyclops2-react.streams.StreamUtils],
for Javaslang Streams use
http://static.javadoc.io/com.aol.cyclops2-react/cyclops-react-javaslang/6.2.2/com/aol/cyclops-react/javaslang/streams/StreamUtils.html[com.aol.cyclops2-react.javaslang.streams.StreamUtils].

The available asynchronous terminal operations as of cylcops 7.1.0 are detailed http://static.javadoc.io/com.aol.cyclops2-react/cyclops-react-sequence-api/7.1.0/com/aol/cyclops-react/sequence/future/FutureOperations.html[in the FutureOperations javadoc]


==== FutureOperations


Terminal operations can now all be called asynchronously e.g.

[source,java]
----
        CompletableFuture size = ReactiveSeq.of(1,2,3,4)
                                                          .futureOperations(exec)
                                                          .count();
----

Available operations

* public CompletableFuture<List<T>> toList()

Asynchronously perform suspended mutable reduction to suspended JDK List

[source,java]
----
 CompletableFuture<List<Data>> myList = ReactiveSeq.of(1,2,3,4)
                                                    .map(this::loadFromDb)
                                                       .futureOperations(getExecutor())

                                                    .toList();
----

* public CompletableFuture<Set<T>> toSet()

Asynchronously perform suspended mutable reduction to suspended JDK Set

[source,java]
----
CompletableFuture<Set<Data>> myList = ReactiveSeq.of(1,2,3,4)
                                                            .map(this::loadFromDb)
                                                            .futureOperations(getExecutor())
                                                            .toSet();
----

* public <U extends Comparable<U>> CompletableFuture<Optional<T>>
minBy(Function<T, U> function) Asynchronously capture the minimum value
in this stream using the provided function
+
[source,java]
----
CompletableFuture<Optional> min =  ReactiveSeq.of(1, 2, 3, 4, 5, 6)
                                                                  .futureOperations(exec)    
                                                                  .minBy(value -> Math.abs(value - 5));
//min CompletableFuture[Optional[5]]  //5-5 =0

* public <U extends Comparable<U>> CompletableFuture<Optional<T>>
maxBy(Function<T, U> function) Asynchronously capture the maximum value
in this stream using the provided function

CompletableFuture<Optional> max =  ReactiveSeq.of(1, 2, 3, 4, 5, 6)
                                                                  .futureOperations(exec)            
                                                                  .maxBy(value -> Math.abs(value - 5));
//min CompletableFuture[Optional[1]]  //Math.abs(1-5) =4

* public <R, A> CompletableFuture<R> collect(Collector<? super T, A, R>
collector) Asynchronously perform suspended Stream collection ```java
CompletableFuture> list = ReactiveSeq.of(1,2,3,4,5)
.futureOperations(exec) .collect(Collectors.toList());

//CompletableFuture[1,2,3,4,5] 
----


