package cyclops.companion;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.Executor;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.*;
import java.util.stream.Stream;

import com.aol.cyclops2.hkt.Higher;
import cyclops.async.Future;
import cyclops.function.Fn3;
import cyclops.function.Fn4;
import cyclops.function.Monoid;
import cyclops.function.Reducer;
import cyclops.monads.WitnessType;
import cyclops.monads.transformers.CompletableFutureT;
import cyclops.typeclasses.Pure;
import cyclops.typeclasses.comonad.Comonad;
import cyclops.typeclasses.foldable.Foldable;
import cyclops.typeclasses.functor.Functor;
import cyclops.typeclasses.instances.General;
import cyclops.typeclasses.monad.*;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import org.reactivestreams.Publisher;

import cyclops.monads.AnyM;
import cyclops.stream.ReactiveSeq;
import com.aol.cyclops2.data.collections.extensions.CollectionX;
import cyclops.collections.ListX;
import com.aol.cyclops2.types.Value;
import cyclops.monads.Witness;

import lombok.experimental.UtilityClass;

/**
 * Utilty methods for working with JDK CompletableFutures
 * 
 * @author johnmcclean
 *
 */
@UtilityClass
public class CompletableFutures {

    public static <T> CompletableFuture<T> ofResult(T value){
        CompletableFuture<T> result = new CompletableFuture<T>();
        result.complete(value);
        return result;
    }

    public static <T,W extends WitnessType<W>> CompletableFutureT<W, T> liftM(CompletableFuture<T> opt, W witness) {
        return CompletableFutureT.of(witness.adapter().unit(opt));
    }

    /**
     * Perform a For Comprehension over a CompletableFuture, accepting 3 generating function.
     * This results in a four level nested internal iteration over the provided CompletableFutures.
     *
     *  <pre>
     * {@code
     *
     *   import static com.aol.cyclops2.reactor.CompletableFutures.forEach4;
     *
    forEach4(CompletableFuture.just(1),
    a-> CompletableFuture.just(a+1),
    (a,b) -> CompletableFuture.<Integer>just(a+b),
    a                  (a,b,c) -> CompletableFuture.<Integer>just(a+b+c),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level CompletableFuture
     * @param value2 Nested CompletableFuture
     * @param value3 Nested CompletableFuture
     * @param value4 Nested CompletableFuture
     * @param yieldingFunction Generates a result per combination
     * @return CompletableFuture with a combined value generated by the yielding function
     */
    public static <T1, T2, T3, R1, R2, R3, R> CompletableFuture<R> forEach4(CompletableFuture<? extends T1> value1,
                                                                            Function<? super T1, ? extends CompletableFuture<R1>> value2,
                                                                            BiFunction<? super T1, ? super R1, ? extends CompletableFuture<R2>> value3,
                                                                            Fn3<? super T1, ? super R1, ? super R2, ? extends CompletableFuture<R3>> value4,
                                                                            Fn4<? super T1, ? super R1, ? super R2, ? super R3, ? extends R> yieldingFunction) {

        return value1.thenCompose(in -> {

            CompletableFuture<R1> a = value2.apply(in);
            return a.thenCompose(ina -> {
                CompletableFuture<R2> b = value3.apply(in,ina);
                return b.thenCompose(inb -> {
                    CompletableFuture<R3> c = value4.apply(in,ina,inb);
                    return c.thenApply(in2 -> yieldingFunction.apply(in, ina, inb, in2));
                });

            });

        });

    }



    /**
     * Perform a For Comprehension over a CompletableFuture, accepting 2 generating function.
     * This results in a three level nested internal iteration over the provided CompletableFutures.
     *
     *  <pre>
     * {@code
     *
     *   import static com.aol.cyclops2.reactor.CompletableFutures.forEach3;
     *
    forEach3(CompletableFuture.just(1),
    a-> CompletableFuture.just(a+1),
    (a,b) -> CompletableFuture.<Integer>just(a+b),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level CompletableFuture
     * @param value2 Nested CompletableFuture
     * @param value3 Nested CompletableFuture
     * @param yieldingFunction Generates a result per combination
     * @return CompletableFuture with a combined value generated by the yielding function
     */
    public static <T1, T2, R1, R2, R> CompletableFuture<R> forEach3(CompletableFuture<? extends T1> value1,
                                                                    Function<? super T1, ? extends CompletableFuture<R1>> value2,
                                                                    BiFunction<? super T1, ? super R1, ? extends CompletableFuture<R2>> value3,
                                                                    Fn3<? super T1, ? super R1, ? super R2, ? extends R> yieldingFunction) {

        return value1.thenCompose(in -> {

            CompletableFuture<R1> a = value2.apply(in);
            return a.thenCompose(ina -> {
                CompletableFuture<R2> b = value3.apply(in,ina);


                    return b.thenApply(in2 -> yieldingFunction.apply(in, ina, in2));


            });

        });

    }


    /**
     * Perform a For Comprehension over a CompletableFuture, accepting a generating function.
     * This results in a two level nested internal iteration over the provided CompletableFutures.
     *
     *  <pre>
     * {@code
     *
     *   import static com.aol.cyclops2.reactor.CompletableFutures.forEach;
     *
    forEach(CompletableFuture.just(1),
    a-> CompletableFuture.just(a+1),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level CompletableFuture
     * @param value2 Nested CompletableFuture
     * @param yieldingFunction Generates a result per combination
     * @return CompletableFuture with a combined value generated by the yielding function
     */
    public static <T, R1, R> CompletableFuture<R> forEach2(CompletableFuture<? extends T> value1, Function<? super T, CompletableFuture<R1>> value2,
                                                          BiFunction<? super T, ? super R1, ? extends R> yieldingFunction) {

        return value1.thenCompose(in -> {

            CompletableFuture<R1> a = value2.apply(in);
            return a.thenApply(ina -> yieldingFunction.apply(in, ina));


            });


    }


    /**
     * Asynchronous sequence operation that convert a Collection of Futures to a Future with a List
     * 
     * <pre>
     * {@code 
     *   CompletableFuture<ListX<Integer>> futures =CompletableFuture.sequence(ListX.of(
     *                                                          CompletableFuture.completedFuture(10),
     *                                                          CompletableFuture.completedFuture(1)));
         //ListX.of(10,1)
     * 
     * }
     * </pre>
     * 
     * 
     * @param fts Collection of Futures to Sequence into a Future with a List
     * @return Future with a List
     */
    public static <T> CompletableFuture<ListX<T>> sequence(final CollectionX<CompletableFuture<T>> fts) {
        return sequence(fts.stream()).thenApply(s -> s.toListX());
    }
    /**
     * Asynchronous sequence operation that convert a Stream of FutureWs to a Future with a Stream
     * 
     * <pre>
     * {@code 
     *   CompletableFuture<ListX<Integer>> futures =CompletableFuture.sequence(ListX.of(
     *                                                          CompletableFuture.completedFuture(10),
     *                                                          CompletableFuture.completedFuture(1)));
         //ListX.of(10,1)
     * 
     * }
     * </pre>
     * 
     * 
     * @param fts Stream of Futures to Sequence into a Future with a Stream
     * @return Future with a Stream
     */
    public static <T> CompletableFuture<ReactiveSeq<T>> sequence(final Stream<CompletableFuture<T>> fts) {
        return AnyM.sequence(fts.map(AnyM::fromCompletableFuture), Witness.completableFuture.INSTANCE)
                .map(ReactiveSeq::fromStream)
                .to(Witness::completableFuture);
        
    }
    /**
     * 
     * Asynchronously accumulate the results only from those Futures which have completed successfully.
     * Also @see {@link CompletableFutures#accumulate(CollectionX, Reducer)} if you would like a failure to result in a CompletableFuture
     * with an error
     * <pre>
     * {@code 
     * 
     * CompletableFuture<Integer> just = CompletableFuture.completedFuture(10);
      CompletableFuture<Integer> none = Future.ofError(new NoSuchElementException())
                                               .getFuture();
       
     * CompletableFuture<PSetX<Integer>> futures = CompletableFutures.accumulateSuccess(ListX.of(just,none,CompletableFuture.completedFuture(1)),Reducers.toPSetX());
       
       //CompletableFuture[PSetX[10,1]]
     *  }
     *  </pre>
     * 
     * @param fts Collection of Futures to accumulate successes
     * @param reducer Reducer to accumulate results
     * @return CompletableFuture asynchronously populated with the accumulate success operation
     */
    public static <T, R> CompletableFuture<R> accumulateSuccess(final CollectionX<CompletableFuture<T>> fts, final Reducer<R> reducer) {
        CompletableFuture<R> result = new CompletableFuture<>();
        Stream<T> successes = fts.stream()
                                                    .filter(ft->!ft.isCompletedExceptionally())
                                                    .map(CompletableFuture::join);
        CompletableFuture.allOf(fts.toArray(new CompletableFuture[0]))
                        .thenRun(()-> result.complete(reducer.mapReduce(successes)))
                        .exceptionally(e->{ result.complete(reducer.mapReduce(successes)); return null;});
        
        return result;    
    }
    /**
     * Asynchronously accumulate the results only from those Futures which have completed successfully, using the supplied mapping function to
     * convert the data from each Future before reducing them using the supplied Monoid (a combining BiFunction/BinaryOperator and identity element that takes two
     * input values of the same type and returns the combined result) {@see cyclops2.Monoids }.
     * 
     * <pre>
     * {@code 
     * CompletableFuture<String> future = CompletableFutures.accumulate(ListX.of(CompletableFuture.completedFuture(10),CompletableFuture.completedFuture(1)),i->""+i,Monoids.stringConcat);
        //CompletableFuture["101"]
     * }
     * </pre>
     * 
     * @param fts Collection of Futures to accumulate successes
     * @param mapper Mapping function to be applied to the result of each Future
     * @param reducer Monoid to combine values from each Future
     * @return CompletableFuture asynchronously populated with the accumulate operation
     */
    public static <T, R> CompletableFuture<R> accumulateSuccess(final CollectionX<CompletableFuture<T>> fts,final Function<? super T, R> mapper,final Monoid<R> reducer) {
        CompletableFuture<R> result = new CompletableFuture<>();
        ReactiveSeq<R> successes = fts.stream()
                                      .filter(ft->!ft.isCompletedExceptionally())
                                      .map(CompletableFuture::join)
                                      .map(mapper);
        CompletableFuture.allOf(fts.toArray(new CompletableFuture[0]))
                        .thenRun(()-> result.complete(successes.reduce(reducer)))
                        .exceptionally(e->{ result.complete(successes.reduce(reducer)); return null;});
        
        return result;    
    }
    /**
     * Asynchronously accumulate the results only from those Futures which have completed successfully,
     *  reducing them using the supplied Monoid (a combining BiFunction/BinaryOperator and identity element that takes two
     * input values of the same type and returns the combined result) {@see cyclops2.Monoids }
     * 
     * <pre>
     * {@code 
     * CompletableFuture<Integer> just =CompletableFuture.completedFuture(10);
     * CompletableFuture<Integer> future =CompletableFutures.accumulate(Monoids.intSum, ListX.of(just,CompletableFuture.completedFuture(1)));
       //CompletableFuture[11]
     * }
     * </pre>
     * 
     * 
     * @param fts Collection of Futures to accumulate successes
     * @param reducer Monoid to combine values from each Future
     * @return CompletableFuture asynchronously populated with the accumulate operation
     */
    public static <T, R> CompletableFuture<T> accumulateSuccess(final Monoid<T> reducer,final CollectionX<CompletableFuture<T>> fts) {
        CompletableFuture<T> result = new CompletableFuture<>();
        ReactiveSeq<T> successes = fts.stream()
                                      .filter(ft->!ft.isCompletedExceptionally())
                                      .map(CompletableFuture::join);
        CompletableFuture.allOf(fts.toArray(new CompletableFuture[0]))
                        .thenRun(()-> result.complete(successes.reduce(reducer)))
                        .exceptionally(e->{ result.complete(successes.reduce(reducer)); return null;});
        
        return result;    
    }
    /**
     * Asynchronously accumulate the results of Futures, a single failure will cause a failed result, using the supplied Reducer {@see cyclops2.Reducers}
     * <pre>
     * {@code 
     * 
     * CompletableFuture<Integer> just =CompletableFuture.completedFuture(10);
       CompletableFuture<Integer> none = Future.ofError(new NoSuchElementException()).getFuture();
       
     * CompletableFuture<PSetX<Integer>> futures = CompletableFutures.accumulateSuccess(ListX.of(just,none,CompletableFuture.completedFuture(1)),Reducers.toPSetX());
       
       //CompletableFuture[PSetX[10,1]]
     *  }
     *  </pre>
     * 
     * @param fts Collection of Futures to accumulate successes
     * @param reducer Reducer to accumulate results
     * @return Future asynchronously populated with the accumulate success operation
     */
    public static <T, R> CompletableFuture<R> accumulate(final CollectionX<CompletableFuture<T>> fts, final Reducer<R> reducer) {
        return sequence(fts).thenApply(s -> s.mapReduce(reducer));
    }
    /**
     * Asynchronously accumulate the results of a batch of Futures which using the supplied mapping function to
     * convert the data from each Future before reducing them using the supplied supplied Monoid (a combining BiFunction/BinaryOperator and identity element that takes two
     * input values of the same type and returns the combined result) {@see cyclops2.Monoids }.
     * A single Failure results in a Failed  Future.
     * 
     * <pre>
     * {@code 
     * CompletableFuture<String> future = Future.accumulate(ListX.of(CompletableFuture.completedFuture(10),CompletableFuture.completedFuture(1)),i->""+i,Monoids.stringConcat);
        //CompletableFuture["101"]
     * }
     * </pre>
     * 
     * @param fts Collection of Futures to accumulate successes
     * @param mapper Mapping function to be applied to the result of each Future
     * @param reducer Monoid to combine values from each Future
     * @return CompletableFuture asynchronously populated with the accumulate operation
     */
    public static <T, R> CompletableFuture<R> accumulate(final CollectionX<CompletableFuture<T>> fts, final Function<? super T, R> mapper,
            final Monoid<R> reducer) {
        return sequence(fts).thenApply(s -> s.map(mapper)
                                             .reduce(reducer));
    }
    /**
     * Asynchronously accumulate the results only from the provided Futures,
     *  reducing them using the supplied Monoid (a combining BiFunction/BinaryOperator and identity element that takes two
     * input values of the same type and returns the combined result) {@see cyclops2.Monoids }.
     * 
     * A single Failure results in a Failed  Future.
     * 
     * <pre>
     * {@code 
     * CompletableFuture<Integer> just =CompletableFuture.completedFuture(10);
     * 
     * CompletableFuture<Integer> future =CompletableFutures.accumulate(Monoids.intSum,ListX.of(just,CompletableFuture.completableFuture(1)));
       //CompletableFuture[11]
     * }
     * </pre>
     * 
     * 
     * @param fts Collection of Futures to accumulate successes
     * @param reducer Monoid to combine values from each Future
     * @return CompletableFuture asynchronously populated with the accumulate operation
     */
    public static <T> CompletableFuture<T> accumulate(final Monoid<T> reducer, final CollectionX<CompletableFuture<T>> fts
           ) {
        return sequence(fts).thenApply(s -> s
                                             .reduce(reducer));
    }
    /**
     * Schedule the population of a CompletableFuture from the provided Supplier, the provided Cron (Quartz format) expression will be used to
     * trigger the population of the CompletableFuture. The provided ScheduledExecutorService provided the thread on which the 
     * Supplier will be executed.
     * 
     * <pre>
     * {@code 
     *  
     *    CompletableFuture<String> future = CompletableFutures.schedule("* * * * * ?", Executors.newScheduledThreadPool(1), ()->"hello");
     *    
     *    //CompletableFuture["hello"]
     * 
     * }</pre>
     * 
     * 
     * @param cron Cron expression in Quartz format
     * @param ex ScheduledExecutorService used to execute the provided Supplier
     * @param t The Supplier to execute to populate the CompletableFuture
     * @return CompletableFuture populated on a Cron based Schedule
     */
    public static <T> CompletableFuture<T> schedule(final String cron, final ScheduledExecutorService ex, final Supplier<T> t) {
        return Future.schedule(cron, ex, t)
                      .getFuture();
    }
    /**
     * Schedule the population of a CompletableFuture from the provided Supplier after the specified delay. The provided ScheduledExecutorService provided the thread on which the 
     * Supplier will be executed.
     * <pre>
     * {@code 
     *  
     *    CompletableFuture<String> future = CompletableFutures.schedule(10l, Executors.newScheduledThreadPool(1), ()->"hello");
     *    
     *    //CompletableFuture["hello"]
     * 
     * }</pre>
     * 
     * @param delay Delay after which the CompletableFuture should be populated
     * @param ex ScheduledExecutorService used to execute the provided Supplier
     * @param t he Supplier to execute to populate the CompletableFuture
     * @return CompletableFuture populated after the specified delay
     */
    public static <T> CompletableFuture<T> schedule(final long delay, final ScheduledExecutorService ex, final Supplier<T> t) {
        return Future.schedule(delay, ex, t)
                      .getFuture();
    }
    /**
     * Combine a CompletableFuture with the provided Value asynchronously (if not completed) using the supplied BiFunction
     * 
     * <pre>
     * {@code 
     *  CompletableFutures.combine(CompletableFuture.completedFuture(10),Maybe.just(20), this::add)
     *  //CompletableFuture [30]
     *  
     *  private int add(int a, int b) {
            return a + b;
        }
     *  
     * }
     * </pre>
     * 
     * @param f CompletableFuture  to combine with a value
     * @param v Value  to combine with
     * @param fn Combining function
     * @return CompletableFuture  combined with supplied value
     */
    public static <T1, T2, R> CompletableFuture<R> combine(final CompletableFuture<? extends T1> f, final Value<? extends T2> v,
            final BiFunction<? super T1, ? super T2, ? extends R> fn) {
        return narrow(Future.of(f)
                             .combine(v, fn)
                             .getFuture());
    }

    /**
     * Combine a CompletableFuture with the provided CompletableFuture asynchronously (if not completed) using the supplied BiFunction
     * 
     * <pre>
     * {@code 
     *  CompletableFutures.combine(CompletableFuture.completedFuture(10),CompletableFuture.completedFuture(20), this::add)
     *  //CompletableFuture [30]
     *  
     *  private int add(int a, int b) {
            return a + b;
        }
     *  
     * }
     * </pre>
     * 
     * @param f CompletableFuture  to combine with a value
     * @param v Value  to combine with
     * @param fn Combining function
     * @return CompletableFuture  combined with supplied value
     */
    public static <T1, T2, R> CompletableFuture<R> combine(final CompletableFuture<? extends T1> f, final CompletableFuture<? extends T2> v,
            final BiFunction<? super T1, ? super T2, ? extends R> fn) {
        return narrow(Future.of(f)
                             .combine(Future.of(v), fn)
                             .getFuture());
    }
    /**
     * Combine an CompletableFuture with the provided Iterable (selecting one element if present) using the supplied BiFunction
     * <pre>
     * {@code 
     *  CompletableFutures.zip(CompletableFuture.completedFuture(10),Arrays.asList(20), this::add)
     *  //CompletableFuture[30]
     *  
     *  private int add(int a, int b) {
            return a + b;
        }
     *  
     * }
     * </pre>
     * @param f CompletableFuture to combine with first element in Iterable (if present)
     * @param v Iterable to combine
     * @param fn Combining function
     * @return CompletableFuture combined with supplied Iterable
     */
    public static <T1, T2, R> CompletableFuture<R> zip(final CompletableFuture<? extends T1> f, final Iterable<? extends T2> v,
            final BiFunction<? super T1, ? super T2, ? extends R> fn) {
        return narrow(Future.of(f)
                             .zip(v, fn)
                             .getFuture());
    }
    /**
     * Combine an CompletableFuture with the provided Publisher (selecting one element if present) using the supplied BiFunction
     * <pre>
     * {@code 
     *  CompletableFutures.zip(Flux.just(10),CompletableFuture.completedResult(10), this::add)
     *  //CompletableFuture[30]
     *  
     *  private int add(int a, int b) {
            return a + b;
        }
     *  
     * }
     * </pre> 
     * 
     * @param p Publisher to combine
     * @param f  CompletableFuture to combine with
     * @param fn Combining function
     * @return CompletableFuture combined with supplied Publisher
     */
    public static <T1, T2, R> CompletableFuture<R> zip(final Publisher<? extends T2> p, final CompletableFuture<? extends T1> f,
            final BiFunction<? super T1, ? super T2, ? extends R> fn) {
        return narrow(Future.of(f)
                             .zipP(p,fn)
                             .getFuture());
    }
    /**
     * Narrow covariant type parameter
     * 
     * @param broad CompletableFuture with covariant type parameter
     * @return Narrowed Optional
     */
    public static <T> CompletableFuture<T> narrow(final CompletableFuture<? extends T> f) {
        return (CompletableFuture<T>) f;
    }
    /**
     * Companion class for creating Type Class instances for working with CompletableFutures
     * @author johnmcclean
     *
     */
    @UtilityClass
    public static class Instances {


        /**
         *
         * Transform a future, mulitplying every element by 2
         *
         * <pre>
         * {@code
         *  CompletableFutureKind<Integer> future = CompletableFutures.functor().map(i->i*2, CompletableFutureKind.widen(CompletableFuture.completedFuture(1,2,3));
         *
         *  //[2,4,6]
         *
         *
         * }
         * </pre>
         *
         * An example fluent api working with CompletableFutures
         * <pre>
         * {@code
         *   CompletableFutureKind<Integer> future = CompletableFutures.unit()
        .unit("hello")
        .apply(h->CompletableFutures.functor().map((String v) ->v.length(), h))
        .convert(CompletableFutureKind::narrowK);
         *
         * }
         * </pre>
         *
         *
         * @return A functor for CompletableFutures
         */
        public static <T,R>Functor<CompletableFutureKind.µ> functor(){
            BiFunction<CompletableFutureKind<T>,Function<? super T, ? extends R>,CompletableFutureKind<R>> map = Instances::map;
            return General.functor(map);
        }
        /**
         * <pre>
         * {@code
         * CompletableFutureKind<String> future = CompletableFutures.unit()
        .unit("hello")
        .convert(CompletableFutureKind::narrowK);

        //CompletableFuture.completedFuture("hello"))
         *
         * }
         * </pre>
         *
         *
         * @return A factory for CompletableFutures
         */
        public static <T> Pure<CompletableFutureKind.µ> unit(){
            return General.<CompletableFutureKind.µ,T>unit(Instances::of);
        }
        /**
         *
         * <pre>
         * {@code
         * import static com.aol.cyclops.hkt.jdk.CompletableFutureKind.widen;
         * import static com.aol.cyclops.util.function.Lambda.l1;
         *
        CompletableFutures.applicative()
        .ap(widen(asCompletableFuture(l1(this::multiplyByTwo))),widen(asCompletableFuture(3)));
         *
         * //[6]
         * }
         * </pre>
         *
         *
         * Example fluent API
         * <pre>
         * {@code
         * CompletableFutureKind<Function<Integer,Integer>> futureFn =CompletableFutures.unit()
         *                                                  .unit(Lambda.l1((Integer i) ->i*2))
         *                                                  .convert(CompletableFutureKind::narrowK);

        CompletableFutureKind<Integer> future = CompletableFutures.unit()
        .unit("hello")
        .apply(h->CompletableFutures.functor().map((String v) ->v.length(), h))
        .apply(h->CompletableFutures.applicative().ap(futureFn, h))
        .convert(CompletableFutureKind::narrowK);

        //CompletableFuture.completedFuture("hello".length()*2))
         *
         * }
         * </pre>
         *
         *
         * @return A zipper for CompletableFutures
         */
        public static <T,R> Applicative<CompletableFutureKind.µ> applicative(){
            BiFunction<CompletableFutureKind< Function<T, R>>,CompletableFutureKind<T>,CompletableFutureKind<R>> ap = Instances::ap;
            return General.applicative(functor(), unit(), ap);
        }
        /**
         *
         * <pre>
         * {@code
         * import static com.aol.cyclops.hkt.jdk.CompletableFutureKind.widen;
         * CompletableFutureKind<Integer> future  = CompletableFutures.monad()
        .flatMap(i->widen(CompletableFutureX.range(0,i)), widen(CompletableFuture.completedFuture(3)))
        .convert(CompletableFutureKind::narrowK);
         * }
         * </pre>
         *
         * Example fluent API
         * <pre>
         * {@code
         *    CompletableFutureKind<Integer> future = CompletableFutures.unit()
        .unit("hello")
        .apply(h->CompletableFutures.monad().flatMap((String v) ->CompletableFutures.unit().unit(v.length()), h))
        .convert(CompletableFutureKind::narrowK);

        //CompletableFuture.completedFuture("hello".length())
         *
         * }
         * </pre>
         *
         * @return Type class with monad functions for CompletableFutures
         */
        public static <T,R> Monad<CompletableFutureKind.µ> monad(){

            BiFunction<Higher<CompletableFutureKind.µ,T>,Function<? super T, ? extends Higher<CompletableFutureKind.µ,R>>,Higher<CompletableFutureKind.µ,R>> flatMap = Instances::flatMap;
            return General.monad(applicative(), flatMap);
        }
        /**
         *
         * <pre>
         * {@code
         *  CompletableFutureKind<String> future = CompletableFutures.unit()
        .unit("hello")
        .apply(h->CompletableFutures.monadZero().filter((String t)->t.startsWith("he"), h))
        .convert(CompletableFutureKind::narrowK);

        //CompletableFuture.completedFuture("hello"));
         *
         * }
         * </pre>
         *
         *
         * @return A filterable monad (with default value)
         */
        public static <T,R> MonadZero<CompletableFutureKind.µ> monadZero(){

            return General.monadZero(monad(), CompletableFutureKind.widen(new CompletableFuture<T>()));
        }
        /**
         * <pre>
         * {@code
         *  CompletableFutureKind<Integer> future = CompletableFutures.<Integer>monadPlus()
        .plus(CompletableFutureKind.widen(CompletableFuture.completedFuture()), CompletableFutureKind.widen(CompletableFuture.completedFuture(10)))
        .convert(CompletableFutureKind::narrowK);
        //CompletableFuture.completedFuture(10))
         *
         * }
         * </pre>
         * @return Type class for combining CompletableFutures by concatenation
         */
        public static <T> MonadPlus<CompletableFutureKind.µ> monadPlus(){
            Monoid<CompletableFuture<T>> mn = Monoids.firstCompleteCompletableFuture();
            Monoid<CompletableFutureKind<T>> m = Monoid.of(CompletableFutureKind.widen(mn.zero()), (f, g)-> CompletableFutureKind.widen(
                    mn.apply(CompletableFutureKind.narrowK(f), CompletableFutureKind.narrowK(g))));

            Monoid<Higher<CompletableFutureKind.µ,?>> m2= (Monoid)m;
            return General.monadPlus(monadZero(),m2);
        }
        /**
         *
         * <pre>
         * {@code
         *  Monoid<CompletableFutureKind<Integer>> m = Monoid.of(CompletableFutureKind.widen(CompletableFuture.completedFuture()), (a,b)->a.isEmpty() ? b : a);
        CompletableFutureKind<Integer> future = CompletableFutures.<Integer>monadPlus(m)
        .plus(CompletableFutureKind.widen(CompletableFuture.completedFuture(5)), CompletableFutureKind.widen(CompletableFuture.completedFuture(10)))
        .convert(CompletableFutureKind::narrowK);
        //CompletableFuture.completedFuture(5))
         *
         * }
         * </pre>
         *
         * @param m Monoid to use for combining CompletableFutures
         * @return Type class for combining CompletableFutures
         */
        public static  <T> MonadPlus<CompletableFutureKind.µ> monadPlus(Monoid<CompletableFutureKind<T>> m){
            Monoid<Higher<CompletableFutureKind.µ,?>> m2= (Monoid)m;
            return General.monadPlus(monadZero(),m2);
        }

        /**
         * @return Type class for traversables with traverse / sequence operations
         */
        public static <C2,T> Traverse<CompletableFutureKind.µ> traverse(){

            return General.traverseByTraverse(applicative(), Instances::traverseA);
        }

        /**
         *
         * <pre>
         * {@code
         * int sum  = CompletableFutures.foldable()
        .foldLeft(0, (a,b)->a+b, CompletableFutureKind.widen(CompletableFuture.completedFuture(3)));

        //3
         *
         * }
         * </pre>
         *
         *
         * @return Type class for folding / reduction operations
         */
        public static <T> Foldable<CompletableFutureKind.µ> foldable(){
            BiFunction<Monoid<T>,Higher<CompletableFutureKind.µ,T>,T> foldRightFn =  (m, l)-> m.apply(m.zero(), CompletableFutureKind.narrowK(l).join());
            BiFunction<Monoid<T>,Higher<CompletableFutureKind.µ,T>,T> foldLeftFn = (m, l)->  m.apply(m.zero(), CompletableFutureKind.narrowK(l).join());
            return General.foldable(foldRightFn, foldLeftFn);
        }
        public static <T> Comonad<CompletableFutureKind.µ> comonad(){
            Function<? super Higher<CompletableFutureKind.µ, T>, ? extends T> extractFn = maybe -> maybe.convert(CompletableFutureKind::narrowK).join();
            return General.comonad(functor(), unit(), extractFn);
        }

        private <T> CompletableFutureKind<T> of(T value){
            return CompletableFutureKind.widen(CompletableFuture.completedFuture(value));
        }
        private static <T,R> CompletableFutureKind<R> ap(CompletableFutureKind<Function< T, R>> lt, CompletableFutureKind<T> future){
            return CompletableFutureKind.widen(lt.thenCombine(future, (a, b)->a.apply(b)));

        }
        private static <T,R> Higher<CompletableFutureKind.µ,R> flatMap(Higher<CompletableFutureKind.µ,T> lt, Function<? super T, ? extends  Higher<CompletableFutureKind.µ,R>> fn){
            return CompletableFutureKind.widen(CompletableFutureKind.narrow(lt).thenCompose(fn.andThen(CompletableFutureKind::narrowK)));
        }
        private static <T,R> CompletableFutureKind<R> map(CompletableFutureKind<T> lt, Function<? super T, ? extends R> fn){
            return CompletableFutureKind.widen(lt.thenApply(fn));
        }


        private static <C2,T,R> Higher<C2, Higher<CompletableFutureKind.µ, R>> traverseA(Applicative<C2> applicative, Function<? super T, ? extends Higher<C2, R>> fn,
                                                                                         Higher<CompletableFutureKind.µ, T> ds){
            CompletableFuture<T> future = CompletableFutureKind.narrowK(ds);
            return applicative.map(CompletableFutureKind::completedFuture, fn.apply(future.join()));
        }

    }
    /**
     * Simulates Higher Kinded Types for CompletableFuture's
     *
     * CompletableFutureKind is a CompletableFuture and a Higher Kinded Type (CompletableFutureKind.µ,T)
     *
     * @author johnmcclean
     *
     * @param <T> Data type stored within the CompletableFuture
     */

    public static interface CompletableFutureKind<T> extends Higher<CompletableFutureKind.µ, T>, CompletionStage<T> {

        /**
         * Witness type
         *
         * @author johnmcclean
         *
         */
        public static class µ {
        }

        /**
         * Construct a HKT encoded completed CompletableFuture
         *
         * @param value To encode inside a HKT encoded CompletableFuture
         * @return Completed HKT encoded CompletableFuture
         */
        public static <T> CompletableFutureKind<T> completedFuture(T value){
            return widen(CompletableFuture.completedFuture(value));
        }

        /**
         * Convert a CompletableFuture to a simulated HigherKindedType that captures CompletableFuture nature
         * and CompletableFuture element data type separately. Recover via @see CompletableFutureKind#narrow
         *
         * If the supplied CompletableFuture implements CompletableFutureKind it is returned already, otherwise it
         * is wrapped into a CompletableFuture implementation that does implement CompletableFutureKind
         *
         * @param CompletableFuture CompletableFuture to widen to a CompletableFutureKind
         * @return CompletableFutureKind encoding HKT info about CompletableFutures
         */
        public static <T> CompletableFutureKind<T> widen(final CompletionStage<T> completableFuture) {
            if (completableFuture instanceof CompletableFutureKind)
                return (CompletableFutureKind<T>) completableFuture;
            return new Box<>(
                    completableFuture);
        }

        /**
         * Convert the raw Higher Kinded Type for CompletableFutureKind types into the CompletableFutureKind type definition class
         *
         * @param future HKT encoded list into a CompletableFutureKind
         * @return CompletableFutureKind
         */
        public static <T> CompletableFutureKind<T> narrow(final Higher<CompletableFutureKind.µ, T> future) {
            return (CompletableFutureKind<T>)future;
        }

        /**
         * Convert the HigherKindedType definition for a CompletableFuture into
         *
         * @param CompletableFuture Type Constructor to convert back into narrowed type
         * @return CompletableFuture from Higher Kinded Type
         */
        public static <T> CompletableFuture<T> narrowK(final Higher<CompletableFutureKind.µ, T> completableFuture) {
            if (completableFuture instanceof CompletionStage) {
                final CompletionStage<T> ft = (CompletionStage<T>) completableFuture;
                return CompletableFuture.completedFuture(1)
                        .thenCompose(f -> ft);
            }
            // this code should be unreachable due to HKT type checker
            final Box<T> type = (Box<T>) completableFuture;
            final CompletionStage<T> stage = type.narrow();
            return CompletableFuture.completedFuture(1)
                    .thenCompose(f -> stage);

        }

        @AllArgsConstructor(access = AccessLevel.PRIVATE)
        static final class Box<T> implements CompletableFutureKind<T> {

            private final CompletionStage<T> boxed;

            /**
             * @return wrapped CompletableFuture
             */
            public CompletionStage<T> narrow() {
                return boxed;
            }

            @Override
            public <U> CompletionStage<U> thenApply(final Function<? super T, ? extends U> fn) {
                return boxed.thenApply(fn);
            }

            @Override
            public <U> CompletionStage<U> thenApplyAsync(final Function<? super T, ? extends U> fn) {
                return boxed.thenApplyAsync(fn);
            }

            @Override
            public <U> CompletionStage<U> thenApplyAsync(final Function<? super T, ? extends U> fn,
                                                         final Executor executor) {
                return boxed.thenApplyAsync(fn, executor);
            }

            @Override
            public CompletionStage<Void> thenAccept(final Consumer<? super T> action) {
                return boxed.thenAccept(action);
            }

            @Override
            public CompletionStage<Void> thenAcceptAsync(final Consumer<? super T> action) {
                return boxed.thenAcceptAsync(action);
            }

            @Override
            public CompletionStage<Void> thenAcceptAsync(final Consumer<? super T> action, final Executor executor) {
                return boxed.thenAcceptAsync(action, executor);
            }

            @Override
            public CompletionStage<Void> thenRun(final Runnable action) {
                return boxed.thenRun(action);
            }

            @Override
            public CompletionStage<Void> thenRunAsync(final Runnable action) {
                return boxed.thenRunAsync(action);
            }

            @Override
            public CompletionStage<Void> thenRunAsync(final Runnable action, final Executor executor) {
                return boxed.thenRunAsync(action, executor);
            }

            @Override
            public <U, V> CompletionStage<V> thenCombine(final CompletionStage<? extends U> other,
                                                         final BiFunction<? super T, ? super U, ? extends V> fn) {
                return boxed.thenCombine(other, fn);
            }

            @Override
            public <U, V> CompletionStage<V> thenCombineAsync(final CompletionStage<? extends U> other,
                                                              final BiFunction<? super T, ? super U, ? extends V> fn) {
                return boxed.thenCombineAsync(other, fn);
            }

            @Override
            public <U, V> CompletionStage<V> thenCombineAsync(final CompletionStage<? extends U> other,
                                                              final BiFunction<? super T, ? super U, ? extends V> fn, final Executor executor) {
                return boxed.thenCombineAsync(other, fn, executor);
            }

            @Override
            public <U> CompletionStage<Void> thenAcceptBoth(final CompletionStage<? extends U> other,
                                                            final BiConsumer<? super T, ? super U> action) {
                return boxed.thenAcceptBoth(other, action);
            }

            @Override
            public <U> CompletionStage<Void> thenAcceptBothAsync(final CompletionStage<? extends U> other,
                                                                 final BiConsumer<? super T, ? super U> action) {
                return boxed.thenAcceptBothAsync(other, action);
            }

            @Override
            public <U> CompletionStage<Void> thenAcceptBothAsync(final CompletionStage<? extends U> other,
                                                                 final BiConsumer<? super T, ? super U> action, final Executor executor) {
                return boxed.thenAcceptBothAsync(other, action, executor);
            }

            @Override
            public CompletionStage<Void> runAfterBoth(final CompletionStage<?> other, final Runnable action) {
                return boxed.runAfterBoth(other, action);
            }

            @Override
            public CompletionStage<Void> runAfterBothAsync(final CompletionStage<?> other, final Runnable action) {
                return boxed.runAfterBothAsync(other, action);
            }

            @Override
            public CompletionStage<Void> runAfterBothAsync(final CompletionStage<?> other, final Runnable action,
                                                           final Executor executor) {
                return boxed.runAfterBothAsync(other, action, executor);
            }

            @Override
            public <U> CompletionStage<U> applyToEither(final CompletionStage<? extends T> other,
                                                        final Function<? super T, U> fn) {
                return boxed.applyToEither(other, fn);
            }

            @Override
            public <U> CompletionStage<U> applyToEitherAsync(final CompletionStage<? extends T> other,
                                                             final Function<? super T, U> fn) {
                return boxed.applyToEitherAsync(other, fn);
            }

            @Override
            public <U> CompletionStage<U> applyToEitherAsync(final CompletionStage<? extends T> other,
                                                             final Function<? super T, U> fn, final Executor executor) {
                return boxed.applyToEitherAsync(other, fn, executor);
            }

            @Override
            public CompletionStage<Void> acceptEither(final CompletionStage<? extends T> other,
                                                      final Consumer<? super T> action) {
                return boxed.acceptEither(other, action);
            }

            @Override
            public CompletionStage<Void> acceptEitherAsync(final CompletionStage<? extends T> other,
                                                           final Consumer<? super T> action) {
                return boxed.acceptEitherAsync(other, action);
            }

            @Override
            public CompletionStage<Void> acceptEitherAsync(final CompletionStage<? extends T> other,
                                                           final Consumer<? super T> action, final Executor executor) {
                return boxed.acceptEitherAsync(other, action, executor);
            }

            @Override
            public CompletionStage<Void> runAfterEither(final CompletionStage<?> other, final Runnable action) {
                return boxed.runAfterEither(other, action);
            }

            @Override
            public CompletionStage<Void> runAfterEitherAsync(final CompletionStage<?> other, final Runnable action) {
                return boxed.runAfterEitherAsync(other, action);
            }

            @Override
            public CompletionStage<Void> runAfterEitherAsync(final CompletionStage<?> other, final Runnable action,
                                                             final Executor executor) {
                return boxed.runAfterEitherAsync(other, action, executor);
            }

            @Override
            public <U> CompletionStage<U> thenCompose(final Function<? super T, ? extends CompletionStage<U>> fn) {
                return boxed.thenCompose(fn);
            }

            @Override
            public <U> CompletionStage<U> thenComposeAsync(final Function<? super T, ? extends CompletionStage<U>> fn) {
                return boxed.thenComposeAsync(fn);
            }

            @Override
            public <U> CompletionStage<U> thenComposeAsync(final Function<? super T, ? extends CompletionStage<U>> fn,
                                                           final Executor executor) {
                return boxed.thenComposeAsync(fn, executor);
            }

            @Override
            public CompletionStage<T> exceptionally(final Function<Throwable, ? extends T> fn) {
                return boxed.exceptionally(fn);
            }

            @Override
            public CompletionStage<T> whenComplete(final BiConsumer<? super T, ? super Throwable> action) {
                return boxed.whenComplete(action);
            }

            @Override
            public CompletionStage<T> whenCompleteAsync(final BiConsumer<? super T, ? super Throwable> action) {
                return boxed.whenCompleteAsync(action);
            }

            @Override
            public CompletionStage<T> whenCompleteAsync(final BiConsumer<? super T, ? super Throwable> action,
                                                        final Executor executor) {
                return boxed.whenCompleteAsync(action, executor);
            }

            @Override
            public <U> CompletionStage<U> handle(final BiFunction<? super T, Throwable, ? extends U> fn) {
                return boxed.handle(fn);
            }

            @Override
            public <U> CompletionStage<U> handleAsync(final BiFunction<? super T, Throwable, ? extends U> fn) {
                return boxed.handleAsync(fn);
            }

            @Override
            public <U> CompletionStage<U> handleAsync(final BiFunction<? super T, Throwable, ? extends U> fn,
                                                      final Executor executor) {
                return boxed.handleAsync(fn, executor);
            }

            @Override
            public CompletableFuture<T> toCompletableFuture() {
                return boxed.toCompletableFuture();
            }

            /* (non-Javadoc)
             * @see java.lang.Object#toString()
             */
            @Override
            public String toString() {
                return "CompletableFutureKind [" + boxed + "]";
            }

            /* (non-Javadoc)
             * @see java.lang.Object#hashCode()
             */
            @Override
            public int hashCode() {
                final int prime = 31;
                int result = 1;
                result = prime * result + ((boxed == null) ? 0 : boxed.hashCode());
                return result;
            }

            /* (non-Javadoc)
             * @see java.lang.Object#equals(java.lang.Object)
             */
            @Override
            public boolean equals(Object obj) {
                if (this == obj)
                    return true;
                if (obj == null)
                    return false;
                if (!(obj instanceof  CompletionStage))
                    return false;
                CompletionStage other = ( CompletionStage) obj;
                if (boxed == null) {
                    if (other != null)
                        return false;
                } else if (!boxed.equals(other))
                    return false;
                return true;
            }


        }
    }
}
