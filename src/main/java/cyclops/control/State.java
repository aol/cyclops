package cyclops.control;

import cyclops.control.Maybe.Nothing;
import cyclops.typeclasses.free.Free;
import cyclops.function.*;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import org.jooq.lambda.tuple.Tuple;
import org.jooq.lambda.tuple.Tuple2;

import java.util.function.BiFunction;
import java.util.function.Function;

@AllArgsConstructor(access = AccessLevel.PRIVATE)
public final class State<S, T> {
    public static class µ {
    }

    private final Fn1<S, Free<Fn0.SupplierKind.µ,Tuple2<S, T>>> runState;


    public Tuple2<S, T> run(S s) {
        return Fn0.run(runState.apply(s));
    }
    public T eval(S s) {
        return Fn0.run(runState.apply(s)).v2;
    }
    public static <S> State<S, S> get() {
        return state(s -> Tuple.tuple(s, s));
    }

    public static <S> State<S, Nothing> transition(Function<? super S,? extends S> f) {
        return state(s -> Tuple.tuple(f.apply(s),(Nothing)Maybe.none()));
    }

    public static <S, T> State<S, T> transition(Function<? super S,? extends S> f, T value) {
        return state(s -> Tuple.tuple(f.apply(s),value));
    }
    public <T2, R> State<S, R> combine(State<S, T2> combine, BiFunction<? super T, ? super T2, ? extends R> combiner) {
        return flatMap(a -> combine.map(b -> combiner.apply(a,b)));
    }

    public <R> State<S, R> map(Function<? super T,? extends R> mapper) {
        return mapState(t -> Tuple.tuple(t.v1, mapper.apply(t.v2)));
    }
    public <R> State<S, R> mapState(Function<Tuple2<S,T>, Tuple2<S, R>> fn) {
        return suspended(s -> runState.apply(s).map(t -> fn.apply(t)));
    }
    private static <S, T> State<S, T> suspended(Fn1<? super S, Free<Fn0.SupplierKind.µ,Tuple2<S, T>>> runF) {
        return new State<>(s -> Fn0.suspend(Lambda.λK(()->runF.apply(s))));
    }

    public <R> State<S, R> flatMap(Function<? super T,? extends  State<S, R>> f) {
        return suspended(s -> runState.apply(s).flatMap(t -> Free.done(f.apply(t.v2).run(t.v1))));
    }
    public static <S, T> State<S, T> constant(T constant) {
        return state(s -> Tuple.tuple(s, constant));
    }

    /*
  * Perform a For Comprehension over a State, accepting 3 generating function.
          * This results in a four level nested internal iteration over the provided States.
   *
           *  <pre>
   * {@code
   *
   *   import static com.aol.cyclops2.reactor.States.forEach4;
   *
      forEach4(State.just(1),
              a-> State.just(a+1),
              (a,b) -> State.<Integer>just(a+b),
              a                  (a,b,c) -> State.<Integer>just(a+b+c),
              Tuple::tuple)
   *
   * }
   * </pre>
          *
          * @param value1 top level State
   * @param value2 Nested State
   * @param value3 Nested State
   * @param value4 Nested State
   * @param yieldingFunction Generates a result per combination
   * @return State with a combined value generated by the yielding function
   */
    public  <R1, R2, R3, R4> State<S,R4> forEach4(Function<? super T, ? extends State<S,R1>> value2,
                                                  BiFunction<? super T, ? super R1, ? extends State<S,R2>> value3,
                                                  Fn3<? super T, ? super R1, ? super R2, ? extends State<S,R3>> value4,
                                                  Fn4<? super T, ? super R1, ? super R2, ? super R3, ? extends R4> yieldingFunction) {


        return this.flatMap(in -> {

            State<S,R1> a = value2.apply(in);
            return a.flatMap(ina -> {
                State<S,R2> b = value3.apply(in,ina);
                return b.flatMap(inb -> {

                    State<S,R3> c = value4.apply(in,ina,inb);

                    return c.map(in2 -> {

                        return yieldingFunction.apply(in, ina, inb, in2);

                    });

                });


            });


        });

    }



    /**
     * Perform a For Comprehension over a State, accepting 2 generating function.
     * This results in a three level nested internal iteration over the provided States.
     *
     *  <pre>
     * {@code
     *
     *   import static com.aol.cyclops2.reactor.States.forEach3;
     *
    forEach3(State.just(1),
    a-> State.just(a+1),
    (a,b) -> State.<Integer>just(a+b),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level State
     * @param value2 Nested State
     * @param value3 Nested State
     * @param yieldingFunction Generates a result per combination
     * @return State with a combined value generated by the yielding function
     */
    public <R1, R2, R4> State<S,R4> forEach3(Function<? super T, ? extends State<S,R1>> value2,
                                             BiFunction<? super T, ? super R1, ? extends State<S,R2>> value3,
                                             Fn3<? super T, ? super R1, ? super R2, ? extends R4> yieldingFunction) {

        return this.flatMap(in -> {

            State<S,R1> a = value2.apply(in);
            return a.flatMap(ina -> {
                State<S,R2> b = value3.apply(in,ina);
                return b.map(in2 -> {
                    return yieldingFunction.apply(in, ina, in2);

                });



            });

        });

    }


    /**
     * Perform a For Comprehension over a State, accepting a generating function.
     * This results in a two level nested internal iteration over the provided States.
     *
     *  <pre>
     * {@code
     *
     *   import static com.aol.cyclops2.reactor.States.forEach;
     *
    forEach(State.just(1),
    a-> State.just(a+1),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level State
     * @param value2 Nested State
     * @param yieldingFunction Generates a result per combination
     * @return State with a combined value generated by the yielding function
     */
    public <R1, R4> State<S,R4> forEach2(Function<? super T, State<S,R1>> value2,
                                         BiFunction<? super T, ? super R1, ? extends R4> yieldingFunction) {

        return this.flatMap(in -> {

            State<S,R1> a = value2.apply(in);
            return a.map(in2 -> {
                return yieldingFunction.apply(in, in2);

            });

        });

    }

    public static <S, T> State<S, T> state(Function<? super S,? extends Tuple2<S, T>> runF) {

        return new State<>(s -> Free.done(runF.apply(s)));
    }

    public static <S> State<S, Nothing> of(S s) {
        return state(__ -> Tuple.tuple(s, (Nothing)Maybe.none()));
    }



}